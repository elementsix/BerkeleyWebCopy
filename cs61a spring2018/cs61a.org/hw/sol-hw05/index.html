<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from cs61a.org/hw/sol-hw05/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 May 2018 23:36:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta name="description" content ="CS 61A: Structure and Interpretation of Computer Programs" />
    <meta name="keywords" content ="CS 61A, Computer Science, CS, 61A, Programming, John DeNero, Berkeley, EECS" />
    <meta name="author" content ="John DeNero" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <script src="../../../cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
    <script src="../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link rel="stylesheet" href="../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,400,500|Work+Sans:400,700">
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link rel="stylesheet" href="../../assets/css/mono-blue.css">
    <link rel="icon" href="../../assets/images/favicon.ico">

    

<link rel="stylesheet" type="text/css" href="../../assets/css/hw.css">


    <title>
Homework 5 Solutions | CS 61A Spring 2018
</title>
  </head>

  <body id="index" class="home">
    <nav class="navbar navbar-default navbar-static-top">
      <div class="container noselect">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-section">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../index.html">CS 61A</a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse-section">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="../../weekly.html">Weekly Schedule</a></li>
            <li><a href="../../office-hours.html">Office Hours</a></li>
            <li><a href="../../staff.html">Staff</a></li>
            <li><a href="../../resources.html">Resources</a></li>
            <li><a href="../../articles/about.html">Policies</a></li>
            <li><a href="http://tutor.cs61a.org/">Tutor</a></li>
            <li><a href="https://piazza.com/berkeley/spring2018/cs61a" target="_blank">Piazza</a></li>
            <li><a href="../../extra.html">Extra</a></li>
          </ul>
        </div>
      </div>
    </nav>

    <main id="content" class="container">
      
<div class='row'>
  <div class='col-md-9'>
    <header>
      <h1>
        
Homework 5 Solutions

        
        <ul class="inline-block list-inline">
          <li><a href="hw05.zip" class="label label-outline">hw05.zip</a></li>
        </ul>
        
      </h1>
    </header>
    
<h2>Solution Files</h2>
<p>You can find the solutions in the <a href="hw05.py">hw05.py</a> file.</p>

    
<h1 id="required-questions">Required Questions</h1>


<h3 class="question" id="q1">Q1: Replace Leaf</h3>

<p>Define <code>replace_leaf</code>, which takes a tree <code>t</code>, a value <code>old</code>, and a value <code>new</code>.
<code>replace_leaf</code> returns a new tree that's the same as <code>t</code> except that every leaf
value equal to <code>old</code>  has been replaced with <code>new</code>.</p>

<solution>

<pre><code>def replace_leaf(t, old, new):
    &quot;&quot;&quot;Returns a new tree where every leaf value equal to old has
    been replaced with new.

    &gt;&gt;&gt; yggdrasil = tree(&#x27;odin&#x27;,
    ...                  [tree(&#x27;balder&#x27;,
    ...                        [tree(&#x27;thor&#x27;),
    ...                         tree(&#x27;loki&#x27;)]),
    ...                   tree(&#x27;frigg&#x27;,
    ...                        [tree(&#x27;thor&#x27;)]),
    ...                   tree(&#x27;thor&#x27;,
    ...                        [tree(&#x27;sif&#x27;),
    ...                         tree(&#x27;thor&#x27;)]),
    ...                   tree(&#x27;thor&#x27;)])
    &gt;&gt;&gt; laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes
    &gt;&gt;&gt; print_tree(replace_leaf(yggdrasil, &#x27;thor&#x27;, &#x27;freya&#x27;))
    odin
      balder
        freya
        loki
      frigg
        freya
      thor
        sif
        freya
      freya
    &gt;&gt;&gt; laerad == yggdrasil # Make sure original tree is unmodified
    True
    &quot;&quot;&quot;
<div class="sol-highlight">    if is_leaf(t) and label(t) == old:
        return tree(new)
    else:
        bs = [replace_leaf(b, old, new) for b in branches(t)]
        return tree(label(t), bs)</div></code></pre>

</solution>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q replace_leaf</code></pre>

<!--
<div class="sol-highlight">

<p>We approach this problem recursively.</p>

<ul>
  <li><p><strong>Base Case:</strong> if the tree is a leaf, we can immediately decide what to
  do. If the label matches the old label, we return a tree with the new
  value. Otherwise, we just return the original tree. In our solution, it
  looks like we always recurse over the branches:</p>

<pre><code>bs = [replace_leaf(b, old, new) for b in branches(t)]</code></pre>

  <p>But this will not do anything for a leaf, since <code>branches(t)</code> is an
  empty sequence. It's also possible to have a separate case.</p></li>
  <li><strong>Otherwise:</strong> we cannot do anything about the current element, since
  we're only allowed to replace at leaves. Therefore, we need to examine
  all of our branches, and replace their leaves. After replacing their
  leaves, we can return an updated tree.</li>
</ul>

<p>Video walkthrough: <a href="https://youtu.be/c4CJBcyrFgI">https://youtu.be/c4CJBcyrFgI</a></p>

</div>
-->

<h3 class="question" id="q2">Q2: Towers of Hanoi</h3>

<p>A classic puzzle called the Towers of Hanoi is a game that consists of three
rods, and a number of disks of different sizes which can slide onto any rod.
The puzzle starts with <code>n</code> disks in a neat stack in ascending order of size on
a <code>start</code> rod, the smallest at the top, forming a conical shape.</p>

<p><img class="img-responsive center-block" src="../../../upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpg" alt="Towers of Hanoi"></p>

<p>The objective of the puzzle is to move the entire stack to an <code>end</code> rod,
obeying the following rules:</p>

<ul>
  <li>Only one disk may be moved at a time.</li>
  <li>Each move consists of taking the top (smallest) disk from one of the rods and
  sliding it onto another rod, on top of the other disks that may already be
  present on that rod.</li>
  <li>No disk may be placed on top of a smaller disk.</li>
</ul>

<p>Complete the definition of <code>move_stack</code>, which prints out the steps required to
move <code>n</code> disks from the <code>start</code> rod to the <code>end</code> rod without violating the
rules.</p>

<solution>

<pre><code>def print_move(origin, destination):
    &quot;&quot;&quot;Print instructions to move a disk.&quot;&quot;&quot;
    print(&quot;Move the top disk from rod&quot;, origin, &quot;to rod&quot;, destination)

def move_stack(n, start, end):
    &quot;&quot;&quot;Print the moves required to move n disks on the start pole to the end
    pole without violating the rules of Towers of Hanoi.

    n &#x2d;&#x2d; number of disks
    start &#x2d;&#x2d; a pole position, either 1, 2, or 3
    end &#x2d;&#x2d; a pole position, either 1, 2, or 3

    There are exactly three poles, and start and end must be different. Assume
    that the start pole has at least n disks of increasing size, and the end
    pole is either empty or has a top disk larger than the top n start disks.

    &gt;&gt;&gt; move_stack(1, 1, 3)
    Move the top disk from rod 1 to rod 3
    &gt;&gt;&gt; move_stack(2, 1, 3)
    Move the top disk from rod 1 to rod 2
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 2 to rod 3
    &gt;&gt;&gt; move_stack(3, 1, 3)
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 1 to rod 2
    Move the top disk from rod 3 to rod 2
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 2 to rod 1
    Move the top disk from rod 2 to rod 3
    Move the top disk from rod 1 to rod 3
    &quot;&quot;&quot;
    assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, &quot;Bad start/end&quot;
<div class="sol-highlight">    if n == 1:
        print_move(start, end)
    else:
        other = 6 &#x2d; start &#x2d; end
        move_stack(n&#x2d;1, start, other)
        print_move(start, end)
        move_stack(n&#x2d;1, other, end)</div></code></pre>

</solution>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q move_stack</code></pre>

<div class="sol-highlight">

<p>To solve the Towers of Hanoi problem for <code>n</code> disks, we need to do three
steps:</p>

<ol>
  <li>Move everything but the last disk (<code>n&#x2d;1</code> disks) to someplace in the
  middle (not the start nor the end rod).</li>
  <li>Move the last disk (a single disk) to the end rod. This must occur
  after step 1 (we have to move everything above it away first)!</li>
  <li>Move everything but the last disk (the disks from step 1) from the
  middle on top of the end rod.</li>
</ol>

<p>We take advantage of the fact that the recursive function <code>move_stack</code> is
guaranteed to move <code>n</code> disks from <code>start</code> to <code>end</code> while obeying the rules
of Towers of Hanoi. The only thing that remains is to make sure that we
have set up the playing board to make that possible.</p>

<p>Since we move a disk to end rod, we run the risk of <code>move_stack</code> doing an
improper move (big disk on top of small disk). But since we're moving the
biggest disk possible, nothing in the <code>n&#x2d;1</code> disks above that is bigger.
Therefore, even though we do not explicitly state the Towers of Hanoi
constraints, we can still carry out the correct steps.</p>

<p>Video walkthrough: <a href="https://youtu.be/VwynGQiCTFM">https://youtu.be/VwynGQiCTFM</a></p>

</div>


<h2 id="mobiles">Mobiles</h2>


<p><strong>Acknowledgements.</strong> This mobile example is based on
a classic problem from Structure and Interpretation of Computer Programs,
<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2">Section 2.2.2</a>.</p>

<p>A <a href="../../../upload.wikimedia.org/wikipedia/commons/7/7e/Modern_mobile-art_mobiles_mobius.jpg">mobile</a> is a type of hanging sculpture. A binary mobile consists of two
sides. Each side is a rod of a certain length, from which hangs either a weight
or another mobile.</p>

<p>We will represent a binary mobile using the data abstractions below, which use
the <code>tree</code> data abstraction for their representation.</p>

<ul>
  <li>A <code>mobile</code> has a left side (index 0) and a right side (index 1).</li>
  <li>A <code>side</code> has a length and a structure, which is either a <code>mobile</code> or <code>weight</code>.</li>
  <li>A <code>weight</code> has a size, which is a positive number.</li>
</ul>

<h3 class="question" id="q3">Q3: Weights</h3>

<p>Implement the <code>weight</code> data abstraction by completing the <code>weight</code> constructor,
the <code>size</code> selector, and the <code>is_weight</code> predicate so that a weight is
represented using a tree. The <code>total_weight</code> example is provided to demonstrate
use of the mobile, side, and weight abstractions.</p>

<pre><code>def mobile(left, right):
    &quot;&quot;&quot;Construct a mobile from a left side and a right side.&quot;&quot;&quot;
    return tree(&#x27;mobile&#x27;, [left, right])

def is_mobile(m):
    return is_tree(m) and label(m) == &#x27;mobile&#x27;

def sides(m):
    &quot;&quot;&quot;Select the sides of a mobile.&quot;&quot;&quot;
    assert is_mobile(m), &quot;must call sides on a mobile&quot;
    return branches(m)

def is_side(m):
    return not is_mobile(m) and not is_weight(m) and type(label(m)) == int</code></pre>

<!-- hack -->

<pre><code>def side(length, mobile_or_weight):
    &quot;&quot;&quot;Construct a side: a length of rod with a mobile or weight at the end.&quot;&quot;&quot;
    return tree(length, [mobile_or_weight])

def length(s):
    &quot;&quot;&quot;Select the length of a side.&quot;&quot;&quot;
    assert is_side(s), &quot;must call length on a side&quot;
    return label(s)

def end(s):
    &quot;&quot;&quot;Select the mobile or weight hanging at the end of a side.&quot;&quot;&quot;
    assert is_side(s), &quot;must call end on a side&quot;
    return branches(s)[0]</code></pre>

<!-- hack -->

<pre><code>def weight(size):
    &quot;&quot;&quot;Construct a weight of some size.&quot;&quot;&quot;
    assert size &gt; 0
<div class="sol-highlight">    return tree(size)</div>
def size(w):
    &quot;&quot;&quot;Select the size of a weight.&quot;&quot;&quot;
<div class="sol-highlight">    return label(w)</div>
def is_weight(w):
    &quot;&quot;&quot;Whether w is a weight, not a mobile.&quot;&quot;&quot;
<div class="sol-highlight">    return is_leaf(w)</div></code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q total_weight</code></pre>

<div class="sol-highlight">

<p>A weight is implemented as a leaf of a tree. Therefore, to determine if
something is a weight, we ask if it is a leaf.</p>

<p>Video walkthrough: <a href="https://youtu.be/PP77C7u-IH4">https://youtu.be/PP77C7u-IH4</a></p>

</div>

<h3 class="question" id="q4">Q4: Balanced</h3>

<p>Implement the <code>balanced</code> function, which returns whether <code>m</code> is a balanced
mobile. A mobile is balanced if two conditions are met:</p>

<ol>
  <li>The torque applied by its left side is equal to that applied by its right
  side. Torque of the left side is the length of the left rod multiplied by the
  total weight hanging from that rod (a similar calculation is used for the
  right side).</li>
  <li>Each of the submobiles hanging off its sides is balanced.</li>
</ol>

<p><em>Hint:</em> You may find it helpful to assume that weights themselves are balanced.</p>

<blockquote><p>It is a DAV (data abstraction violation) to assume that a mobile itself
is a list. Instead, we should use selectors to get the sides of mobile.</p>

<p>However, since we know that the <code>sides</code> of a mobile is a list of sides,
we can index into the list returned by <code>sides(m)</code> for some mobile <code>m</code>
without committing a DAV.</p>

<p>Take a look at <code>total_weight</code> to see this in action.</p></blockquote>

<pre><code>def balanced(m):
    &quot;&quot;&quot;Return whether m is balanced.

    &gt;&gt;&gt; t, u, v = examples()
    &gt;&gt;&gt; balanced(t)
    True
    &gt;&gt;&gt; balanced(v)
    True
    &gt;&gt;&gt; w = mobile(side(3, t), side(2, u))
    &gt;&gt;&gt; balanced(w)
    False
    &gt;&gt;&gt; balanced(mobile(side(1, v), side(1, w)))
    False
    &gt;&gt;&gt; balanced(mobile(side(1, w), side(1, v)))
    False
    &quot;&quot;&quot;
<div class="sol-highlight">    if is_weight(m):
        return True
    else:
        left, right = sides(m)
        left_s, right_s = end(left), end(right)
        torque_left = length(left) * total_weight(left_s)
        torque_right = length(right) * total_weight(right_s)
        return balanced(left_s) and balanced(right_s) and torque_left == torque_right</div></code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q balanced</code></pre>

<div class="sol-highlight">

<p>The balanced weights assumption is important, since we will be solving
this recursively like many other tree problems (even though this is not
explicitly a tree).</p>

<ul>
  <li><p><strong>Base case:</strong> if we are checking a weight, then we know that this is
  balanced. Why is this an appropriate base case? There are two possible
  approaches to this:</p>

  <ol>
    <li>Because we know that our data structures so far are trees, weights
    are the simplest possible tree since we have chosen to implement
    them as leaves.</li>
    <li>We also know that from an ADT standpoint, weights are the terminal
    item in a mobile. There can be no further mobile structures under
    this weight, so it makes sense to stop check here.</li>
  </ol></li>
  <li><strong>Otherwise:</strong> note that it is important to do a recursive call to check
  if both sides are balanced. However, we also need to do the basic
  comparison of looking at the total weight of both sides as well as their
  length. For example if both sides are a weight, trivially, they will
  both be balanced. However, the torque must be equal in order for the
  entire mobile to balanced (i.e. it's insufficient to just check if the
  sides are balanced).</li>
</ul>

<p>Video walkthrough: <a href="https://youtu.be/I5LNvo0R3Jw">https://youtu.be/I5LNvo0R3Jw</a></p>

</div>


<h2 id="object-oriented-programming">Object Oriented Programming</h2>


<h3 class="question" id="q5">Q5: Retirement</h3>

<p>Add a <code>time_to_retire</code> method to the <code>Account</code> class that takes an <code>amount</code>. It
returns how many years the holder would need to wait in order for the current
<code>balance</code> to grow to at least <code>amount</code>, assuming that the bank adds <code>balance</code>
times the <code>interest</code> rate at the end of every year.</p>

<pre><code>class Account:
    &quot;&quot;&quot;An account has a balance and a holder.

    &gt;&gt;&gt; a = Account(&#x27;John&#x27;)
    &gt;&gt;&gt; a.deposit(10)
    10
    &gt;&gt;&gt; a.balance
    10
    &gt;&gt;&gt; a.interest
    0.02

    &gt;&gt;&gt; a.time_to_retire(10.25) # 10 &#x2d;&gt; 10.2 &#x2d;&gt; 10.404
    2
    &gt;&gt;&gt; a.balance               # balance should not change
    10
    &gt;&gt;&gt; a.time_to_retire(11)    # 10 &#x2d;&gt; 10.2 &#x2d;&gt; ... &#x2d;&gt; 11.040808032
    5
    &gt;&gt;&gt; a.time_to_retire(100)
    117
    &quot;&quot;&quot;

    interest = 0.02  # A class attribute

    def __init__(self, account_holder):
        self.holder = account_holder
        self.balance = 0

    def deposit(self, amount):
        &quot;&quot;&quot;Add amount to balance.&quot;&quot;&quot;
        self.balance = self.balance + amount
        return self.balance

    def withdraw(self, amount):
        &quot;&quot;&quot;Subtract amount from balance if funds are available.&quot;&quot;&quot;
        if amount &gt; self.balance:
            return &#x27;Insufficient funds&#x27;
        self.balance = self.balance &#x2d; amount
        return self.balance

    def time_to_retire(self, amount):
        &quot;&quot;&quot;Return the number of years until balance would grow to amount.&quot;&quot;&quot;
        assert self.balance &gt; 0 and amount &gt; 0 and self.interest &gt; 0
<div class="sol-highlight">        future = self.balance
        years = 0
        while future &lt; amount:
            future += self.interest * future
            years += 1
        return years</div></code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q Account</code></pre>

<div class="sol-highlight">

<p>We take of our current balance, and simulate the growth from interest over
many years. We stop once we hit the target value.</p>

<p>Note that the problem solving procedure does not differ very much from an
non OOP problem. The main difference here is make sure that we do not
change the account balance while in the process of calculating the future
balance. Therefore, something along these lines is necessary:</p>

<pre><code>future = self.balance</code></pre>

<p>Video walkthrough: <a href="https://youtu.be/fQzeZcI-4a0">https://youtu.be/fQzeZcI-4a0</a></p>

</div>

<h3 class="question" id="q6">Q6: Free Checking</h3>

<p>Implement <code>FreeChecking</code>, which is like the <code>CheckingAccount</code> from lecture
except that it only charges a withdraw fee after 2 free withdrawals.  Such a
deal! Even unsuccessful withdrawals count against the free quota, but only
successful withdrawals actually incur a fee.</p>

<pre><code>class FreeChecking(Account):
    &quot;&quot;&quot;A bank account that charges for withdrawals, but the first two are free!

    &gt;&gt;&gt; ch = FreeChecking(&#x27;Jack&#x27;)
    &gt;&gt;&gt; ch.balance = 20
    &gt;&gt;&gt; ch.withdraw(100)  # First one&#x27;s free
    &#x27;Insufficient funds&#x27;
    &gt;&gt;&gt; ch.withdraw(3)    # And the second
    17
    &gt;&gt;&gt; ch.balance
    17
    &gt;&gt;&gt; ch.withdraw(3)    # Ok, two free withdrawals is enough
    13
    &gt;&gt;&gt; ch.withdraw(3)
    9
    &gt;&gt;&gt; ch2 = FreeChecking(&#x27;John&#x27;)
    &gt;&gt;&gt; ch2.balance = 10
    &gt;&gt;&gt; ch2.withdraw(3) # No fee
    7
    &gt;&gt;&gt; ch.withdraw(3)  # ch still charges a fee
    5
    &gt;&gt;&gt; ch.withdraw(5)  # Not enough to cover fee + withdraw
    &#x27;Insufficient funds&#x27;
    &quot;&quot;&quot;
    withdraw_fee = 1
    free_withdrawals = 2

<div class="sol-highlight">    def __init__(self, account_holder):
        Account.__init__(self, account_holder)
        self.withdrawals = 0

    def withdraw(self, amount):
        self.withdrawals += 1
        fee = 0
        if self.withdrawals &gt; self.free_withdrawals:
            fee = self.withdraw_fee
        return Account.withdraw(self, amount + fee)

    # Alternative solution where you don&#x27;t need to include init.
    # Check out the video solution for more.
    def withdraw(self, amount):
        self.free_withdrawals &#x2d;= 1
        if self.free_withdrawals &gt;= 0:
            return Account.withdraw(self, amount)
        return Account.withdraw(self, amount + self.withdraw_fee)</div></code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q FreeChecking</code></pre>

<div class="sol-highlight">

<p>We can take advantage of inheritance to make sure we add just what we need
to <code>withdraw</code>.</p>

<ul>
  <li>For starters, a withdrawal with a fee is the same as the original
  withdraw amount plus the amount from the fee. We can therefore represent
  a <code>FreeChecking</code> withdraw as a "regular" <code>Account</code> withdraw in this way.</li>
  <li>On top of the note from before, we need to do a little bit of extra
  bookkeeping to make sure the first few withdrawals do not add the extra
  fee. We can either create a new instance attribute or modify an existing
  one.</li>
</ul>

<p>Video walkthrough: <a href="https://youtu.be/flIMJC2lY3M">https://youtu.be/flIMJC2lY3M</a></p>

</div>


<h2 id="mutation">Mutation</h2>


<h3 class="question" id="q7">Q7: Counter</h3>

<p>Define a function <code>make_counter</code> that returns a <code>counter</code> function, which takes
a string and returns the number of times that the function has been called on
that string.</p>

<solution>

<pre><code>def make_counter():
    &quot;&quot;&quot;Return a counter function.

    &gt;&gt;&gt; c = make_counter()
    &gt;&gt;&gt; c(&#x27;a&#x27;)
    1
    &gt;&gt;&gt; c(&#x27;a&#x27;)
    2
    &gt;&gt;&gt; c(&#x27;b&#x27;)
    1
    &gt;&gt;&gt; c(&#x27;a&#x27;)
    3
    &gt;&gt;&gt; c2 = make_counter()
    &gt;&gt;&gt; c2(&#x27;b&#x27;)
    1
    &gt;&gt;&gt; c2(&#x27;b&#x27;)
    2
    &gt;&gt;&gt; c(&#x27;b&#x27;) + c2(&#x27;b&#x27;)
    5
    &quot;&quot;&quot;
<div class="sol-highlight">    totals = {}
    def counter(key):
        totals[key] = totals.get(key, 0) + 1
        return totals[key]
    return counter</div></code></pre>

</solution>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q make_counter</code></pre>

<div class="sol-highlight">

<p>Note that we do not need to use the <code>nonlocal</code> keyword here; we are just
modifying the contents of dictionary, not changing the thing that <code>totals</code>
is storing.</p>

<p><code>totals.get(key, 0)</code> will attempt to retrieve the <code>key</code> from the
dictionary, and returns a default value of <code>0</code> if it is not found. We
could also implement this by always seeding the dictionary with a default
value if the item doesn't already exist:</p>

<pre><code>def make_counter():
    totals = {}
    def counter(key):
        if key not in totals:
            totals[key] = 0
        totals[key] += 1
        return totals[key]
    return counter</code></pre>

<p>Video walkthrough: <a href="https://youtu.be/bSUr0OUISuE">https://youtu.be/bSUr0OUISuE</a></p>

</div>

<h3 class="question" id="q8">Q8: Next Fibonacci</h3>

<p>Write a function <code>make_fib</code> that returns a function that returns the
next Fibonacci number each time it is called. (The Fibonacci sequence begins with 0
and then 1, after which each element is the sum of the preceding two.)
Use a <code>nonlocal</code> statement!</p>

<solution>

<pre><code>def make_fib():
    &quot;&quot;&quot;Returns a function that returns the next Fibonacci number
    every time it is called.

    &gt;&gt;&gt; fib = make_fib()
    &gt;&gt;&gt; fib()
    0
    &gt;&gt;&gt; fib()
    1
    &gt;&gt;&gt; fib()
    1
    &gt;&gt;&gt; fib()
    2
    &gt;&gt;&gt; fib()
    3
    &gt;&gt;&gt; fib2 = make_fib()
    &gt;&gt;&gt; fib() + sum([fib2() for _ in range(5)])
    12
    &quot;&quot;&quot;
<div class="sol-highlight">    cur, next = 0, 1
    def fib():
        nonlocal cur, next
        result = cur
        cur, next = next, cur + next
        return result
    return fib</div></code></pre>

</solution>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q make_fib</code></pre>

<div class="sol-highlight">

<p>In between calls to <code>fib</code>, we need to remember how far we have gotten in
the sequence somehow. We do this by track the <code>cur</code> and the <code>next</code>
Fibonacci number, but this also be done by just tracking the current
position in the sequence, and returning something like <code>fib_iter(n)</code>.
While this solution works (and is included below), it is quite wasteful in
terms of computation and so we prefer the official solution.</p>

<pre><code>def make_fib():
    def fib_iter(n):
        cur, next = 0, 1
        while n &gt; 0:
            cur, next = next, cur + next
            n &#x2d;= 1
        return cur

    n = 0
    def fib():
        nonlocal n
        result = fib_iter(n)
        n += 1
        return result

    return fib</code></pre>

<p>Consider that to calculate <code>fib_iter(n+1)</code>, it takes just one more step
after <code>fib_iter(n)</code>.</p>

<p>Video walkthrough: <a href="https://youtu.be/Tkp1wrXiQjI">https://youtu.be/bSUr0OUISuE</a></p>

</div>

<h3 class="question" id="q9">Q9: Password Protected Account</h3>

<p>In lecture, we saw how to use functions to create mutable objects.
Here, for example, is the function <code>make_withdraw</code> which produces a
function that can withdraw money from an account:</p>

<pre><code>def make_withdraw(balance):
    &quot;&quot;&quot;Return a withdraw function with BALANCE as its starting balance.
    &gt;&gt;&gt; withdraw = make_withdraw(1000)
    &gt;&gt;&gt; withdraw(100)
    900
    &gt;&gt;&gt; withdraw(100)
    800
    &gt;&gt;&gt; withdraw(900)
    &#x27;Insufficient funds&#x27;
    &quot;&quot;&quot;
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
           return &#x27;Insufficient funds&#x27;
        balance = balance &#x2d; amount
        return balance
    return withdraw</code></pre>

<p>Write a version of the <code>make_withdraw</code> function that returns
password-protected withdraw functions. That is, <code>make_withdraw</code> should
take a password argument (a string) in addition to an initial balance.
The returned function should take two arguments: an amount to withdraw
and a password.</p>

<p>A password-protected <code>withdraw</code> function should only process
withdrawals that include a password that matches the original.  Upon
receiving an incorrect password, the function should:</p>

<ol>
  <li>Store that incorrect password in a list, and</li>
  <li>Return the string 'Incorrect password'.</li>
</ol>

<p>If a withdraw function has been called three times with incorrect
passwords <code>p1</code>, <code>p2</code>, and <code>p3</code>, then it is locked.  All subsequent
calls to the function should return:</p>

<pre><code>&quot;Your account is locked. Attempts: [&lt;p1&gt;, &lt;p2&gt;, &lt;p3&gt;]&quot;</code></pre>

<p>The incorrect passwords may be the same or different:</p>

<solution>

<pre><code>def make_withdraw(balance, password):
    &quot;&quot;&quot;Return a password&#x2d;protected withdraw function.

    &gt;&gt;&gt; w = make_withdraw(100, &#x27;hax0r&#x27;)
    &gt;&gt;&gt; w(25, &#x27;hax0r&#x27;)
    75
    &gt;&gt;&gt; error = w(90, &#x27;hax0r&#x27;)
    &gt;&gt;&gt; error
    &#x27;Insufficient funds&#x27;
    &gt;&gt;&gt; error = w(25, &#x27;hwat&#x27;)
    &gt;&gt;&gt; error
    &#x27;Incorrect password&#x27;
    &gt;&gt;&gt; new_bal = w(25, &#x27;hax0r&#x27;)
    &gt;&gt;&gt; new
    50
    &gt;&gt;&gt; w(75, &#x27;a&#x27;)
    &#x27;Incorrect password&#x27;
    &gt;&gt;&gt; w(10, &#x27;hax0r&#x27;)
    40
    &gt;&gt;&gt; w(20, &#x27;n00b&#x27;)
    &#x27;Incorrect password&#x27;
    &gt;&gt;&gt; w(10, &#x27;hax0r&#x27;)
    &quot;Your account is locked. Attempts: [&#x27;hwat&#x27;, &#x27;a&#x27;, &#x27;n00b&#x27;]&quot;
    &gt;&gt;&gt; w(10, &#x27;l33t&#x27;)
    &quot;Your account is locked. Attempts: [&#x27;hwat&#x27;, &#x27;a&#x27;, &#x27;n00b&#x27;]&quot;
    &gt;&gt;&gt; type(w(10, &#x27;l33t&#x27;)) == str
    True
    &quot;&quot;&quot;
<div class="sol-highlight">    attempts = []
    def withdraw(amount, password_attempt):
        nonlocal balance
        if len(attempts) == 3:
            return &#x27;Your account is locked. Attempts: &#x27; + str(attempts)
        if password_attempt != password:
            attempts.append(password_attempt)
            return &#x27;Incorrect password&#x27;
        if amount &gt; balance:
            return &#x27;Insufficient funds&#x27;
        balance = balance &#x2d; amount
        return balance
    return withdraw</div></code></pre>

</solution>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q make_withdraw</code></pre>

<div class="sol-highlight">

<p>A couple of things to note:</p>

<ul>
  <li>The <code>attempts</code> list does not need to be nonlocal. We're just mutating
  the list here, not reassigning it.</li>
  <li>The last few lines of our <code>withdraw</code> function are the same as the
  <code>withdraw</code> from lecture. There isn't much to add on top of that -- just
  the list operations and the password checks.</li>
</ul>

<p>Video walkthrough: <a href="https://youtu.be/YyjQoug0Mtg">https://youtu.be/YyjQoug0Mtg</a></p>

</div>

<h3 class="question" id="q10">Q10: Joint Account</h3>

<p>Suppose that our banking system requires the ability to make joint
accounts.  Define a function <code>make_joint</code> that takes three arguments.</p>

<ol>
  <li>A password-protected <code>withdraw</code> function,</li>
  <li>The password with which that <code>withdraw</code> function was defined, and</li>
  <li>A new password that can also access the original account.</li>
</ol>

<p>The <code>make_joint</code> function returns a <code>withdraw</code> function that provides
additional access to the original account using <em>either</em> the new or old
password. Both functions draw from the same balance. Incorrect
passwords provided to either function will be stored and cause the
functions to be locked after three wrong attempts.</p>

<p><em>Hint</em>: The solution is short (less than 10 lines) and contains no string
literals!  The key is to call <code>withdraw</code> with the right password and amount,
then interpret the result.  You may assume that all failed attempts to withdraw
will return some string (for incorrect passwords, locked accounts, or
insufficient funds), while successful withdrawals will return a number.</p>

<p>Use <code>type(value) == str</code> to test if some <code>value</code> is a string:</p>

<solution>

<pre><code>def make_joint(withdraw, old_password, new_password):
    &quot;&quot;&quot;Return a password&#x2d;protected withdraw function that has joint access to
    the balance of withdraw.

    &gt;&gt;&gt; w = make_withdraw(100, &#x27;hax0r&#x27;)
    &gt;&gt;&gt; w(25, &#x27;hax0r&#x27;)
    75
    &gt;&gt;&gt; make_joint(w, &#x27;my&#x27;, &#x27;secret&#x27;)
    &#x27;Incorrect password&#x27;
    &gt;&gt;&gt; j = make_joint(w, &#x27;hax0r&#x27;, &#x27;secret&#x27;)
    &gt;&gt;&gt; w(25, &#x27;secret&#x27;)
    &#x27;Incorrect password&#x27;
    &gt;&gt;&gt; j(25, &#x27;secret&#x27;)
    50
    &gt;&gt;&gt; j(25, &#x27;hax0r&#x27;)
    25
    &gt;&gt;&gt; j(100, &#x27;secret&#x27;)
    &#x27;Insufficient funds&#x27;

    &gt;&gt;&gt; j2 = make_joint(j, &#x27;secret&#x27;, &#x27;code&#x27;)
    &gt;&gt;&gt; j2(5, &#x27;code&#x27;)
    20
    &gt;&gt;&gt; j2(5, &#x27;secret&#x27;)
    15
    &gt;&gt;&gt; j2(5, &#x27;hax0r&#x27;)
    10

    &gt;&gt;&gt; j2(25, &#x27;password&#x27;)
    &#x27;Incorrect password&#x27;
    &gt;&gt;&gt; j2(5, &#x27;secret&#x27;)
    &quot;Your account is locked. Attempts: [&#x27;my&#x27;, &#x27;secret&#x27;, &#x27;password&#x27;]&quot;
    &gt;&gt;&gt; j(5, &#x27;secret&#x27;)
    &quot;Your account is locked. Attempts: [&#x27;my&#x27;, &#x27;secret&#x27;, &#x27;password&#x27;]&quot;
    &gt;&gt;&gt; w(5, &#x27;hax0r&#x27;)
    &quot;Your account is locked. Attempts: [&#x27;my&#x27;, &#x27;secret&#x27;, &#x27;password&#x27;]&quot;
    &gt;&gt;&gt; make_joint(w, &#x27;hax0r&#x27;, &#x27;hello&#x27;)
    &quot;Your account is locked. Attempts: [&#x27;my&#x27;, &#x27;secret&#x27;, &#x27;password&#x27;]&quot;
    &quot;&quot;&quot;
<div class="sol-highlight">    error = withdraw(0, old_password)
    if type(error) == str:
        return error
    def joint(amount, password_attempt):
        if password_attempt == new_password:
            return withdraw(amount, old_password)
        return withdraw(amount, password_attempt)
    return joint</div></code></pre>

</solution>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q make_joint</code></pre>

<div class="sol-highlight">
The hint should alert you to the fact that returned strings should
indicate an error, which is useful for the initial setup phase.

<p>To make sure that we correctly created the joint account, we attempt to
withdraw <code>0</code> from it using the supplied password. If this failed, we
should exit immediately without creating the account, following the
guidance in the doctests.</p>

<p>Otherwise, we have successfully created the joint account! We now know the
old password is valid, but remember that the original password-protected
account does not know about any new passwords that a joint account might
accept. Therefore, when we see something matching the new password, we
still have to access the account using the old password.</p>

<p>Video walkthrough: <a href="https://youtu.be/h5MvIM1k1II">https://youtu.be/h5MvIM1k1II</a></p>

</div>


<h1 id="extra-questions">Extra Questions</h1>


<blockquote><p>Extra questions are not worth extra credit and are entirely optional. They are
designed to challenge you to think creatively!</p></blockquote>


<h2 id="interval">Interval</h2>


<p><strong>Acknowledgements.</strong> This interval arithmetic example is based on
a classic problem from Structure and Interpretation of Computer Programs,
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.4">Section 2.1.4</a>.</p>

<p><strong>Introduction.</strong> Alyssa P. Hacker is designing a system to help people
solve engineering problems. One feature she wants to provide in her
system is the ability to manipulate inexact quantities (such as
measured parameters of physical devices) with known precision, so that
when computations are done with such approximate quantities the results
will be numbers of known precision.</p>

<p>Alyssa's idea is to implement interval arithmetic as a set of
arithmetic operations for combining "intervals" (objects that represent
the range of possible values of an inexact quantity). The result of
adding, subracting, multiplying, or dividing two intervals is itself an
interval, representing the range of the result.</p>

<p>Alyssa postulates the existence of an abstract object called an
"interval" that has two endpoints: a lower bound and an upper bound.
She also presumes that, given the endpoints of an interval, she can
construct the interval using the data constructor interval.   Using the
constructor and selectors, she defines the following operations:</p>

<pre><code>def str_interval(x):
    &quot;&quot;&quot;Return a string representation of interval x.&quot;&quot;&quot;
    return &#x27;{0} to {1}&#x27;.format(lower_bound(x), upper_bound(x))

def add_interval(x, y):
    &quot;&quot;&quot;Return an interval that contains the sum of any value in interval x and
    any value in interval y.&quot;&quot;&quot;
    lower = lower_bound(x) + lower_bound(y)
    upper = upper_bound(x) + upper_bound(y)
    return interval(lower, upper)</code></pre>

<h3 class="question" id="q11">Q11: Interval Abstraction</h3>

<p>Alyssa's program is incomplete because she has not specified the implementation
of the interval abstraction. She has implemented the constructor for you; fill
in the implementation of the selectors.</p>

<pre><code>def interval(a, b):
    &quot;&quot;&quot;Construct an interval from a to b.&quot;&quot;&quot;
<div class="sol-highlight">    assert a &lt;= b, &#x27;Lower bound cannot be greater than upper bound&#x27;</div>    return [a, b]

def lower_bound(x):
    &quot;&quot;&quot;Return the lower bound of interval x.&quot;&quot;&quot;
<div class="sol-highlight">    return x[0]</div>
def upper_bound(x):
    &quot;&quot;&quot;Return the upper bound of interval x.&quot;&quot;&quot;
<div class="sol-highlight">    return x[1]</div></code></pre>

<p>Use Ok to unlock and test your code:</p><pre><code class="nohighlight">python3 ok -q interval -u
python3 ok -q interval</code></pre>

<p>Louis Reasoner has also provided an implementation of interval
multiplication. Beware: there are some data abstraction violations, so help him
fix his code before someone <a href="https://youtu.be/QwoghxwETng">sets it on fire</a>.</p>

<pre><code>def mul_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the product of any value in x and any
    value in y.&quot;&quot;&quot;
    p1 = x[0] * y[0]
    p2 = x[0] * y[1]
    p3 = x[1] * y[0]
    p4 = x[1] * y[1]
    return [min(p1, p2, p3, p4), max(p1, p2, p3, p4)]</code></pre>

<p>Use Ok to unlock and test your code:</p><pre><code class="nohighlight">python3 ok -q mul_interval -u
python3 ok -q mul_interval</code></pre>

<div class="sol-highlight">

<p>Video walkthrough: <a href="https://youtu.be/RiLrqgBm4Dk">https://youtu.be/RiLrqgBm4Dk</a></p>

</div>

<h3 class="question" id="q12">Q12: Sub Interval</h3>

<p>Using reasoning analogous to Alyssa's, define a subtraction function for
intervals. Try to reuse functions that have already been implemented.</p>

<pre><code>def sub_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the difference between any value in x
    and any value in y.&quot;&quot;&quot;
<div class="sol-highlight">    negative_y = interval(&#x2d;upper_bound(y), &#x2d;lower_bound(y))
    return add_interval(x, negative_y)</div></code></pre>

<p>Use Ok to unlock and test your code:</p><pre><code class="nohighlight">python3 ok -q sub_interval -u
python3 ok -q sub_interval</code></pre>

<div class="sol-highlight">

<p>Video walkthrough: <a href="https://youtu.be/s37VvawB0vE">https://youtu.be/s37VvawB0vE</a></p>

</div>

<h3 class="question" id="q13">Q13: Div Interval</h3>

<p>Alyssa implements division below by multiplying by the reciprocal of
<code>y</code>. Ben Bitdiddle, an expert systems programmer, looks over Alyssa's
shoulder and comments that it is not clear what it means to divide by
an interval that spans zero. Add an <code>assert</code> statement to Alyssa's code
to ensure that no such interval is used as a divisor:</p>

<pre><code>def div_interval(x, y):
    &quot;&quot;&quot;Return the interval that contains the quotient of any value in x divided by
    any value in y. Division is implemented as the multiplication of x by the
    reciprocal of y.&quot;&quot;&quot;
<div class="sol-highlight">    assert not (lower_bound(y) &lt;= 0 &lt;= upper_bound(y)), &#x27;Divide by zero&#x27;</div>    reciprocal_y = interval(1/upper_bound(y), 1/lower_bound(y))
    return mul_interval(x, reciprocal_y)</code></pre>

<p>Use Ok to unlock and test your code:</p><pre><code class="nohighlight">python3 ok -q div_interval -u
python3 ok -q div_interval</code></pre>

<div class="sol-highlight">

<p>Video walkthrough: <a href="https://youtu.be/jNR7tmV1lMk">https://youtu.be/jNR7tmV1lMk</a></p>

</div>

<h3 class="question" id="q14">Q14: Par Diff</h3>

<p>After considerable work, Alyssa P. Hacker delivers her finished system.  Several
years later, after she has forgotten all about it, she gets a frenzied call from
an irate user, Lem E. Tweakit. It seems that Lem has noticed that the
<a href="https://en.wikipedia.org/wiki/Series_and_parallel_circuits#Resistors_2">formula for parallel resistors</a>
can be written in two algebraically equivalent ways:</p>

<pre><code>par1(r1, r2) = (r1 * r2) / (r1 + r2)</code></pre>

<p>or</p>

<pre><code>par2(r1, r2) = 1 / (1/r1 + 1/r2)</code></pre>

<p>He has written the following two programs, each of which computes the
<code>parallel_resistors</code> formula differently::</p>

<pre><code>def par1(r1, r2):
    return div_interval(mul_interval(r1, r2), add_interval(r1, r2))

def par2(r1, r2):
    one = interval(1, 1)
    rep_r1 = div_interval(one, r1)
    rep_r2 = div_interval(one, r2)
    return div_interval(one, add_interval(rep_r1, rep_r2))</code></pre>

<p>Lem complains that Alyssa's program gives different answers for the two
ways of computing. This is a serious complaint.</p>

<p>Demonstrate that Lem is right. Investigate the behavior of the system
on a variety of arithmetic expressions. Make some intervals <code>r1</code> and
<code>r2</code>, and show that <code>par1</code> and <code>par2</code> can give different results.</p>

<pre><code>def check_par():
    &quot;&quot;&quot;Return two intervals that give different results for parallel resistors.

    &gt;&gt;&gt; r1, r2 = check_par()
    &gt;&gt;&gt; x = par1(r1, r2)
    &gt;&gt;&gt; y = par2(r1, r2)
    &gt;&gt;&gt; lower_bound(x) != lower_bound(y) or upper_bound(x) != upper_bound(y)
    True
    &quot;&quot;&quot;
<div class="sol-highlight">    r1 = interval(1, 2)</div><div class="sol-highlight">    r2 = interval(3, 4)</div>    return r1, r2</code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q check_par</code></pre>

<div class="sol-highlight">

<p>Video walkthrough: <a href="https://youtu.be/H8slb5KCbU4">https://youtu.be/H8slb5KCbU4</a></p>

</div>

<h3 class="question" id="q15">Q15: Multiple References</h3>

<p>Eva Lu Ator, another user, has also noticed the different intervals
computed by different but algebraically equivalent expressions. She
says that the problem is multiple references to the same interval.</p>

<p>The Multiple References Problem: a formula to compute with intervals
using Alyssa's system will produce tighter error bounds if it can be
written in such a form that no variable that represents an uncertain
number is repeated.</p>

<p>Thus, she says, <code>par2</code> is a better program for parallel resistances
than <code>par1</code>. Is she right? Why? Write a function that returns a string
containing a written explanation of your answer:</p>

<pre><code>def multiple_references_explanation():
<div class="sol-highlight">    return &quot;&quot;&quot;The multiple reference problem exists.  The true value
    within a particular interval is fixed (though unknown).  Nested
    combinations that refer to the same interval twice may assume two different
    true values for the same interval, which is an error that results in
    intervals that are larger than they should be.

    Consider the case of i * i, where i is an interval from &#x2d;1 to 1.  No value
    within this interval, when squared, will give a negative result.  However,
    our mul_interval function will allow us to choose 1 from the first
    reference to i and &#x2d;1 from the second, giving an erroneous lower bound of
    &#x2d;1.

    Hence, a program like par2 is better than par1 because it never combines
    the same interval more than once.
    &quot;&quot;&quot;</div></code></pre>

<div class="sol-highlight">

<p>Video walkthrough: <a href="https://youtu.be/H8slb5KCbU4">https://youtu.be/H8slb5KCbU4</a></p>

</div>

<h3 class="question" id="q16">Q16: Quadratic</h3>

<p>Write a function <code>quadratic</code> that returns the interval of all values
<code>f(t)</code> such that <code>t</code> is in the argument interval <code>x</code> and <code>f(t)</code> is a
<a href="http://en.wikipedia.org/wiki/Quadratic_function">quadratic function</a>:</p>

<pre><code>f(t) = a*t*t + b*t + c</code></pre>

<p>Make sure that your implementation returns the smallest such interval,
one that does not suffer from the multiple references problem.</p>

<p><em>Hint</em>: the derivative <code>f&#x27;(t) = 2*a*t + b</code>, and so the extreme
point of the quadratic is <code>&#x2d;b/(2*a)</code>:</p>

<pre><code>def quadratic(x, a, b, c):
    &quot;&quot;&quot;Return the interval that is the range of the quadratic defined by
    coefficients a, b, and c, for domain interval x.

    &gt;&gt;&gt; str_interval(quadratic(interval(0, 2), &#x2d;2, 3, &#x2d;1))
    &#x27;&#x2d;3 to 0.125&#x27;
    &gt;&gt;&gt; str_interval(quadratic(interval(1, 3), 2, &#x2d;3, 1))
    &#x27;0 to 10&#x27;
    &quot;&quot;&quot;
<div class="sol-highlight">    extremum = &#x2d;b / (2*a)
    f = lambda x: a * x * x + b * x + c
    l, u, e = map(f, (lower_bound(x), upper_bound(x), extremum))
    if extremum &gt;= lower_bound(x) and extremum &lt;= upper_bound(x):
        return interval(min(l, u, e), max(l, u, e))
    else:
        return interval(min(l, u), max(l, u))</div></code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q quadratic</code></pre>

<div class="sol-highlight">

<p>Video walkthrough: <a href="https://youtu.be/qgSn_RNBs4A">https://youtu.be/qgSn_RNBs4A</a></p>

</div>

<h3 class="question" id="q17">Q17: Polynomial</h3>

<p>Write a function <code>polynomial</code> that takes an interval <code>x</code> and a list of
coefficients <code>c</code>, and returns the interval containing all values of <code>f(t)</code> for
<code>t</code> in interval <code>x</code>, where:</p>

<pre><code>f(t) = c[k&#x2d;1] * pow(t, k&#x2d;1) + c[k&#x2d;2] * pow(t, k&#x2d;2) + ... + c[0] * 1</code></pre>

<p>Like <code>quadratic</code>, your <code>polynomial</code> function should return the smallest such
interval, one that does not suffer from the multiple references problem.</p>

<p><em>Hint</em>: You can approximate this result. Try using <a href="http://www.composingprograms.com/pages/16-higher-order-functions.html#example-newton-s-method">Newton's
method</a>.</p>

<pre><code>def polynomial(x, c):
    &quot;&quot;&quot;Return the interval that is the range of the polynomial defined by
    coefficients c, for domain interval x.

    &gt;&gt;&gt; str_interval(polynomial(interval(0, 2), [&#x2d;1, 3, &#x2d;2]))
    &#x27;&#x2d;3 to 0.125&#x27;
    &gt;&gt;&gt; str_interval(polynomial(interval(1, 3), [1, &#x2d;3, 2]))
    &#x27;0 to 10&#x27;
    &gt;&gt;&gt; str_interval(polynomial(interval(0.5, 2.25), [10, 24, &#x2d;6, &#x2d;8, 3]))
    &#x27;18.0 to 23.0&#x27;
    &quot;&quot;&quot;
<div class="sol-highlight">    def add_fn(coeff, k, f):
        return lambda x: coeff * pow(x, k) + f(x)

    def add_dfn(coeff, k, df):
        return lambda x: k * coeff * pow(x, k&#x2d;1) + df(x)

    def add_ddfn(coeff, k, ddf):
        return lambda x: k * (k&#x2d;1) * coeff * pow(x, k&#x2d;2) + ddf(x)

    # Define the polynomial and its first and second derivatives.
    f = lambda x: 0
    df = lambda x: 0
    ddf = lambda x: 0
    for k, coeff in enumerate(c):
        f = add_fn(coeff, k, f)
        if k &gt; 0:
            df = add_dfn(coeff, k, df)
        if k &gt; 1:
            ddf = add_ddfn(coeff, k, ddf)

    # Find as many extreme points as we can using Newton&#x27;s method
    lower, upper = lower_bound(x), upper_bound(x)
    num_steps = 20
    step = (upper &#x2d; lower) / num_steps
    starts = [lower + k * step for k in range(num_steps)]
    extremums = [find_zero(df, ddf, n) for n in starts]

    # Filter for the interval x and return
    ns = [n for n in extremums if n &gt; lower and n &lt; upper] + [lower, upper]
    values = [f(n) for n in ns]
    return interval(min(values), max(values))</div>
<div class="sol-highlight"># Newton&#x27;s method from lecture

def improve(update, close, guess=1, max_updates=100):
    &quot;&quot;&quot;Iteratively improve guess with update until close(guess) is true or
    max_updates have been applied.&quot;&quot;&quot;
    k = 0
    while not close(guess) and k &lt; max_updates:
        guess = update(guess)
        k = k + 1
    return guess

def approx_eq(x, y, tolerance=1e&#x2d;15):
    return abs(x &#x2d; y) &lt; tolerance

def find_zero(f, df, guess=1):
    &quot;&quot;&quot;Return a zero of the function f with derivative df.&quot;&quot;&quot;
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero, guess)

def newton_update(f, df):
    &quot;&quot;&quot;Return an update function for f with derivative df,
    using Newton&#x27;s method.&quot;&quot;&quot;
    def update(x):
        return x &#x2d; f(x) / df(x)
    return update</div></code></pre>

<p>Use Ok to test your code:</p><pre><code class="nohighlight">python3 ok -q polynomial</code></pre>

  </div>

  <div class='col-md-3 sticky'>
    <nav class='hidden-print hidden-sm hidden-xs sidebar'>
      <ul>
  <li><a href="#required-questions">Required Questions</a></li>
  <ul>
    <li><a href="#q1">Q1: Replace Leaf</a></li>
    <li><a href="#q2">Q2: Towers of Hanoi</a></li>
  </ul>
  <ul>
    <li><a href="#mobiles">Mobiles</a></li>
    <ul>
      <li><a href="#q3">Q3: Weights</a></li>
      <li><a href="#q4">Q4: Balanced</a></li>
    </ul>
    <li><a href="#object-oriented-programming">Object Oriented Programming</a></li>
    <ul>
      <li><a href="#q5">Q5: Retirement</a></li>
      <li><a href="#q6">Q6: Free Checking</a></li>
    </ul>
    <li><a href="#mutation">Mutation</a></li>
    <ul>
      <li><a href="#q7">Q7: Counter</a></li>
      <li><a href="#q8">Q8: Next Fibonacci</a></li>
      <li><a href="#q9">Q9: Password Protected Account</a></li>
      <li><a href="#q10">Q10: Joint Account</a></li>
    </ul>
  </ul>
  <li><a href="#extra-questions">Extra Questions</a></li>
  <ul>
    <li><a href="#interval">Interval</a></li>
    <ul>
      <li><a href="#q11">Q11: Interval Abstraction</a></li>
      <li><a href="#q12">Q12: Sub Interval</a></li>
      <li><a href="#q13">Q13: Div Interval</a></li>
      <li><a href="#q14">Q14: Par Diff</a></li>
      <li><a href="#q15">Q15: Multiple References</a></li>
      <li><a href="#q16">Q16: Quadratic</a></li>
      <li><a href="#q17">Q17: Polynomial</a></li>
    </ul>
  </ul>
</ul>
    </nav>
  </div>
</div>

    </main>

    <footer class="container">
      <div class="row text-center">
        <div class="col col-sm-4">
          <h3><a href="../../index.html">CS 61A</a></h3>
          <ul class="nav nav-pills nav-stacked">
            <li><a href="../../weekly.html">Weekly Schedule</a></li>
            <li><a href="../../office-hours.html">Office Hours</a></li>
            <li><a href="../../staff.html">Staff</a></li>
          </ul>
        </div>
        <div class="col col-sm-4">
          <h3><a href="../../resources.html">Resources</a></h3>
          <ul class="nav nav-pills nav-stacked">
            <li><a href="../../articles/studying.html">Studying Guide</a></li>
            <li><a href="../../articles/debugging.html">Debugging Guide</a></li>
            <li><a href="../../articles/composition.html">Composition Guide</a></li>
          </ul>
        </div>
        <div class="col col-sm-4">
          <h3><a href="../../articles/about.html">Policies</a></h3>
          <ul class="nav nav-pills nav-stacked">
            <li><a href="../../articles/about.html#assignments">Assignments</a></li>
            <li><a href="../../articles/about.html#exams">Exams</a></li>
            <li><a href="../../articles/about.html#grading">Grading</a></li>
          </ul>
        </div>
      </div>
    </footer>

    

<script>
  $('.sidebar ul').addClass('nav nav-stacked noselect');
  $('body').scrollspy({
    target: '.sidebar',
    offset: 40
  });
</script>

  </body>

<!-- Mirrored from cs61a.org/hw/sol-hw05/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 May 2018 23:36:13 GMT -->
</html>