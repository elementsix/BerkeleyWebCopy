<!DOCTYPE html>
<!--==============================================================================
	           "GitHub HTML5 Pandoc Template" v1.2 — by Tristano Ajmone           
	==============================================================================
	(c) Tristano Ajmone, 2017, MIT License (MIT). Project's home repository:

	- https://github.com/tajmone/pandoc-goodies

	This template reuses source code taken from the following projects:

	- GitHub Markdown CSS: © Sindre Sorhus, MIT License (MIT):
	  https://github.com/sindresorhus/github-markdown-css

	- Primer CSS: © 2016 GitHub Inc., MIT License (MIT):
	  http://primercss.io/
	==============================================================================-->
<html>

<!-- Mirrored from www.eecs70.org/static/notes/n6.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 May 2018 00:39:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Modular Arithmetic</title>
<style type="text/css">@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff')}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5;word-wrap:break-word;box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects;color:#0366d6;text-decoration:none}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body h1{margin:.67em 0}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #dfe2e5}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:100%;overflow:auto}.markdown-body td,.markdown-body th{padding:0}.markdown-body blockquote{margin:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.markdown-body pre{font:12px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;word-wrap:normal}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{font-size:11px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#6a737d}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:"\00a0"}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fcfcfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.flash{position:relative;padding:16px;color:#246;background-color:#e2eef9;border:1px solid #bac6d3;border-radius:3px}.flash p:last-child{margin-bottom:0}.flash-messages{margin-bottom:24px}.flash-warn{color:#4c4a42;background-color:#fff9ea;border-color:#dfd8c2}.flash-error{color:#911;background-color:#fcdede;border-color:#d2b2b2}.flash-success{color:#22662c;background-color:#e2f9e5;border-color:#bad3be}.flash-plain{color:#4c4a42;background-color:#f5f5f5;border-color:#c1c1c1}.figure{text-align:center;}</style>
  <style type="text/css">code{white-space: pre;}</style>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {equationNumbers: {autoNumber: "AMS"}}
    });
  </script>
  <script src="../../../cdn.mathjax.org/mathjax/latest/MathJax2ba6.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article class="markdown-body">
<header>
<h1 class="title">Modular Arithmetic</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#modular-arithmetic">Modular Arithmetic</a></li>
<li><a href="#computation">Computation</a><ul>
<li><a href="#set-representation">Set Representation</a></li>
</ul></li>
<li><a href="#exponentiation">Exponentiation</a></li>
<li><a href="#inverses">Inverses</a><ul>
<li><a href="#computing-the-multiplicative-inverse">Computing the Multiplicative Inverse</a></li>
<li><a href="#euclids-algorithm-for-computing-the-gcd">Euclid’s Algorithm for Computing the GCD</a></li>
<li><a href="#extended-euclids-algorithm">Extended Euclid’s Algorithm</a><ul>
<li><a href="#examples">Examples</a></li>
<li><a href="#algorithm">Algorithm</a></li>
</ul></li>
<li><a href="#chinese-remainder-theorem">Chinese Remainder Theorem</a></li>
</ul></li>
</ul>
</nav>
<h1 id="modular-arithmetic" class="unnumbered">Modular Arithmetic</h1>
<p>In several settings, such as error-correcting codes and cryptography, we sometimes wish to work over a smaller range of numbers. Modular arithmetic is useful in these settings, since it limits numbers to a predefined range <span class="math inline">\(\{0,1,\ldots, N-1\}\)</span>, and wraps around whenever you try to leave this range — like the hand of a clock (where <span class="math inline">\(N = 12\)</span>) or the days of the week (where <span class="math inline">\(N = 7\)</span>).</p>
<p><span><strong>Example: Calculating the Time</strong></span>. When you calculate the time, you automatically use modular arithmetic. For example, if you are asked what time it will be <span class="math inline">\(13\)</span> hours from 1 pm, you say 2 am rather than 14. Let’s assume our clock displays <span class="math inline">\(12\)</span> as <span class="math inline">\(0\)</span>. This is limiting numbers to a predefined range, <span class="math inline">\(\{0, 1,2,\ldots,11\}\)</span>. Whenever you add two numbers in this setting, you divide by <span class="math inline">\(12\)</span> and provide the remainder as the answer.</p>
<p>If we wanted to know what the time would be <span class="math inline">\(24\)</span> hours from 2 pm, the answer is easy. It would be 2 pm. This is true not just for <span class="math inline">\(24\)</span> hours, but for any multiple of <span class="math inline">\(12\)</span> hours. What about <span class="math inline">\(25\)</span> hours from 2 pm? Since the time <span class="math inline">\(24\)</span> hours from 2 pm is still 2 pm, <span class="math inline">\(25\)</span> hours later it would be 3 pm. Another way to say this is that we add <span class="math inline">\(1\)</span> hour, which is the remainder when we divide <span class="math inline">\(25\)</span> by <span class="math inline">\(12\)</span>.</p>
<p>This example shows that under certain circumstances it makes sense to do arithmetic within the confines of a particular number (<span class="math inline">\(12\)</span> in this example). That is, we only keep track of the remainder when we divide by <span class="math inline">\(12\)</span>, and when we need to add two numbers, instead we just add the remainders. This method is quite efficient in the sense of keeping intermediate values as small as possible, and we shall see in later notes how useful it can be.</p>
<p>More generally we can define <span class="math inline">\(x \bmod m\)</span> (in words <span class="math inline">\(x\)</span> modulo <span class="math inline">\(m\)</span>) to be the remainder <span class="math inline">\(r\)</span> when we divide <span class="math inline">\(x\)</span> by <span class="math inline">\(m\)</span>, i.e. if <span class="math inline">\(x\bmod m = r\)</span>, then <span class="math inline">\(x = mq + r\)</span> where <span class="math inline">\(0 \leq r \leq m-1\)</span> and <span class="math inline">\(q\)</span> is an integer. Thus <span class="math inline">\(5 = 29 \bmod 12\)</span> and <span class="math inline">\(3 = 13 \bmod 5\)</span>.</p>
<h1 id="computation" class="unnumbered">Computation</h1>
<p>If we wish to calculate <span class="math inline">\(x + y \bmod m\)</span>, we would first add <span class="math inline">\(x +y\)</span> and the calculate the remainder when we divide the result by <span class="math inline">\(m\)</span>. For example, if <span class="math inline">\(x = 14\)</span> and <span class="math inline">\(y = 25\)</span> and <span class="math inline">\(m = 12\)</span>, we would compute the remainder when we divide <span class="math inline">\(x + y = 14 + 25 = 39\)</span> by <span class="math inline">\(12\)</span>, to get the answer <span class="math inline">\(3\)</span>. Notice that we would get the same answer if we first computed <span class="math inline">\(2 = x \bmod 12\)</span> and <span class="math inline">\(1 = y \bmod 12\)</span> and added the results modulo <span class="math inline">\(12\)</span> to get <span class="math inline">\(3\)</span>. The same holds for subtraction: <span class="math inline">\(x - y \bmod 12\)</span> is <span class="math inline">\(-11 \bmod 12\)</span>, which is <span class="math inline">\(1\)</span>. Again, we could have directly obtained this as <span class="math inline">\(2 - 1\)</span> by first simplifying <span class="math inline">\(x \bmod 12\)</span> and <span class="math inline">\(y \bmod 12\)</span>.</p>
<p>This is even more convenient if we are trying to multiply: to compute <span class="math inline">\(xy \bmod 12\)</span>, we could first compute <span class="math inline">\(xy = 14 \times 25 = 350\)</span> and then compute the remainder when we divide by <span class="math inline">\(12\)</span>, which is <span class="math inline">\(2\)</span>. Notice that we get the same answer if we first compute <span class="math inline">\(2 = x \bmod 12\)</span> and <span class="math inline">\(1 = y \bmod 12\)</span> and simply multiply the results modulo <span class="math inline">\(12\)</span>.</p>
<p>More generally, while carrying out any sequence of additions, subtractions or multiplications <span class="math inline">\(\bmod m\)</span>, we get the same answer even if we reduce any intermediate results <span class="math inline">\(\bmod m\)</span>. This can considerably simplify the calculations.</p>
<h2 id="set-representation" class="unnumbered">Set Representation</h2>
<p>There is an alternate view of modular arithmetic which helps understand all this better. For any integer <span class="math inline">\(m\)</span> we say that <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are <span><em>congruent modulo <span class="math inline">\(m\)</span></em></span> if they differ by a multiple of <span class="math inline">\(m\)</span>, or in symbols, <span class="math display">\[x \equiv y \pmod m \iff \mbox{$m$ divides $(x-y)$}.\]</span></p>
<p>For example, <span class="math inline">\(29\)</span> and <span class="math inline">\(5\)</span> are congruent modulo <span class="math inline">\(12\)</span> because <span class="math inline">\(12\)</span> divides <span class="math inline">\(29 - 5\)</span>. We can also write <span class="math inline">\(22 \equiv -2 \pmod{12}\)</span>. Notice that <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are congruent modulo <span class="math inline">\(m\)</span> iff they have the same remainder modulo <span class="math inline">\(m\)</span>.</p>
<p>What is the set of numbers that are congruent to <span class="math inline">\(0 \pmod{12}\)</span>? These are all the multiples of <span class="math inline">\(12\)</span>:<br />
<span class="math inline">\(\{\ldots, -36, -24, -12, 0, 12, 24, 36, \ldots \}\)</span>. What about the set of numbers that are congruent to <span class="math inline">\(1 \pmod{12}\)</span>? These are all the numbers that give a remainder <span class="math inline">\(1\)</span> when divided by <span class="math inline">\(12\)</span>: <span class="math inline">\(\{\ldots, -35, -23, -11, 1, 13, 25, 37, \ldots \}\)</span>. Similarly the set of numbers congruent to <span class="math inline">\(2 \pmod{12}\)</span> is <span class="math inline">\(\{\ldots, -34, -22, -10, 2, 14, 26, 38, \ldots \}\)</span>. Notice in this way we get <span class="math inline">\(12\)</span> such sets of integers, and every integer belongs to one and only one of these sets.</p>
<p>In general if we work modulo <span class="math inline">\(m\)</span>, then we get <span class="math inline">\(m\)</span> such disjoint sets whose union is the set of all integers. We can think of each set as represented by the unique element it contains in the range <span class="math inline">\((0,\ldots,m-1)\)</span>. The set represented by element <span class="math inline">\(i\)</span> would be all numbers <span class="math inline">\(z\)</span> such that <span class="math inline">\(z = mx + i\)</span> for some integer <span class="math inline">\(x\)</span>. Observe that all of these numbers have remainder <span class="math inline">\(i\)</span> when divided by <span class="math inline">\(m\)</span>; they are therefore congruent modulo <span class="math inline">\(m\)</span>.</p>
<p>We can understand the operations of addition, subtraction and multiplication in terms of these sets. When we add two numbers, say <span class="math inline">\(x \equiv 2 \pmod{12}\)</span> and <span class="math inline">\(y \equiv 1 \pmod{12}\)</span>, it does not matter which <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> we pick from the two sets, since the result is always an element of the set that contains <span class="math inline">\(3\)</span>. The same is true about subtraction and multiplication. It should now be clear that the elements of each set are interchangeable when computing modulo <span class="math inline">\(m\)</span>, and this is why we can reduce any intermediate results modulo <span class="math inline">\(m\)</span>.</p>
<p>Here is a more formal way of stating this observation:</p>
<p><span id="thm:thm2" class="pandoc-numbering-text thm"><strong>Theorem 1</strong></span></p>
<p><em>If <span class="math inline">\(a \equiv c \pmod{m}\)</span> and <span class="math inline">\(b \equiv d \pmod{m}\)</span>, then <span class="math inline">\(a+b \equiv c+d \pmod{m}\)</span> and <span class="math inline">\(a\cdot b \equiv c\cdot d \pmod{m}\)</span>.</em></p>
<p><em>Proof</em>. We know that <span class="math inline">\(c=a+k\cdot m\)</span> and <span class="math inline">\(d=b+\ell\cdot m\)</span>, so <span class="math inline">\(c+d=a+k\cdot m + b+\ell\cdot m = a+b+(k+\ell)\cdot m\)</span>, which means that <span class="math inline">\(a+b \equiv c+d \pmod{m}\)</span>. The proof for multiplication is similar and left as an exercise. <span class="math inline">\(\square\)</span></p>
<p>What this theorem tells us is that we can always reduce any arithmetic expression modulo <span class="math inline">\(m\)</span> into a natural number smaller than <span class="math inline">\(m\)</span>. As an example, consider the expresion <span class="math inline">\((13+11)\cdot 18 \bmod 7\)</span>. Using the above Theorem several times we can write: <span class="math display">\[\begin{aligned}
    (13+11)\cdot 18 &amp;\equiv (6+4)\cdot 4 \pmod 7\cr
    &amp;= 10\cdot 4 \pmod 7\cr
    &amp;\equiv 3\cdot 4 \pmod 7\cr
    &amp;= 12 \pmod 7\cr
    &amp;\equiv 5 \pmod 7.\cr
\end{aligned}\]</span> In summary, we can always do basic arithmetic (multiplication, addition, subtraction, and division) calculations modulo <span class="math inline">\(m\)</span> by reducing intermediate results modulo <span class="math inline">\(m\)</span>.</p>
<h1 id="exponentiation" class="unnumbered">Exponentiation</h1>
<p>Another standard operation in arithmetic algorithms (this is used heavily in primality testing and RSA) is raising one number to a power modulo another number, i.e., how do we compute <span class="math inline">\(x^y\bmod m\)</span>, where <span class="math inline">\(x,y,m\)</span> are natural numbers and <span class="math inline">\(m&gt;0\)</span>? A naïve approach would be to compute the sequence <span class="math inline">\(x\bmod m,x^2 \bmod m,x^3\bmod m,\ldots\)</span> up to <span class="math inline">\(y\)</span> terms, but this requires time exponential in the number of bits in <span class="math inline">\(y\)</span>. We can do much better using the trick of <span><em>repeated squaring</em></span>:</p>
<pre><code>algorithm mod-exp(x, y, m)
if y = 0 then return(1)
else
  z = mod-exp(x, y div 2, m)
  if y mod 2 = 0 then return(z * z mod m)
  else return(x * z * z mod m)</code></pre>
<p>This algorithm uses the fact that any <span class="math inline">\(y&gt;0\)</span> can be written as <span class="math inline">\(y=2a\)</span> or <span class="math inline">\(y=2a + 1\)</span>, where <span class="math inline">\(a=\lfloor y/2 \rfloor\)</span> (which we have written as <code>y div 2</code> in the above pseudo-code), plus the facts <span class="math display">\[\begin{aligned}
    x^{2a} &amp;= (x^a)^2; \qquad \text{and}\cr
    x^{2a+1} &amp;= x\cdot(x^a)^2.\cr
\end{aligned}\]</span></p>
<p>As a useful exercise, you should use these facts to construct a formal inductive argument that the algorithm always returns the correct value.</p>
<p>What is its running time? The main task here, as is usual for recursive algorithms, is to figure out how many recursive calls are made. But we can see that the second argument, <span class="math inline">\(y\)</span>, is being (integer) divided by <span class="math inline">\(2\)</span> in each call, so the number of recursive calls is exactly equal to the number of bits, <span class="math inline">\(n\)</span>, in <span class="math inline">\(y\)</span>. (The same is true, up to a small constant factor, if we let <span class="math inline">\(n\)</span> be the number of decimal digits in <span class="math inline">\(y\)</span>.) Thus, if we charge only constant time for each arithmetic operation (<code>div</code>, <code>mod</code>, etc.) then the running time of <code>mod-exp</code> is <span class="math inline">\(O(n)\)</span>.</p>
<p>In a more realistic model (where we count the cost of operations at the bit level), we would need to look more carefully at the cost of each recursive call. Note first that the test on <span class="math inline">\(y\)</span> in the <span>if</span>-statement just involves looking at the least significant bit of <span class="math inline">\(y\)</span>, and the computation of <span class="math inline">\(\lfloor y/2 \rfloor\)</span> is just a shift in the bit representation. Hence each of these operations takes only constant time. The cost of each recursive call is therefore dominated by the <code>mod</code> operation<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> in the final result. A fuller analysis of such algorithms is performed in 170.</p>
<h1 id="inverses" class="unnumbered">Inverses</h1>
<p>We have so far discussed addition, multiplication and exponentiation. Subtraction is the inverse of addition and just requires us to notice that subtracting <span class="math inline">\(b\)</span> modulo <span class="math inline">\(m\)</span> is the same as adding <span class="math inline">\(-b \equiv m-b \pmod{m}\)</span>.</p>
<p>What about division? This is a bit harder<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. Over the reals dividing by a number <span class="math inline">\(x\)</span> is the same as multiplying by <span class="math inline">\(y = 1/x\)</span>. Here <span class="math inline">\(y\)</span> is that number such that <span class="math inline">\(x \cdot y = 1\)</span>. Of course we have to be careful when <span class="math inline">\(x = 0\)</span>, since such a <span class="math inline">\(y\)</span> does not exist. Similarly, when we wish to divide by <span class="math inline">\(x \pmod{m}\)</span>, we need to find <span class="math inline">\(y \pmod{m}\)</span> such that <span class="math inline">\(x \cdot y \equiv 1 \pmod{m}\)</span>; then dividing by <span class="math inline">\(x\)</span> modulo <span class="math inline">\(m\)</span> will be the same as multiplying by <span class="math inline">\(y\)</span> modulo <span class="math inline">\(m\)</span>. Such a <span class="math inline">\(y\)</span> is called the <span><em>multiplicative inverse</em></span> of <span class="math inline">\(x\)</span> modulo <span class="math inline">\(m\)</span>. In our present setting of modular arithmetic, can we be sure that <span class="math inline">\(x\)</span> has an inverse mod <span class="math inline">\(m\)</span>, and if so, is it unique (modulo <span class="math inline">\(m\)</span>) and can we compute it?</p>
<p>As a first example, take <span class="math inline">\(x=8\)</span> and <span class="math inline">\(m=15\)</span>. Then <span class="math inline">\(2x=16 \equiv 1\pmod{15}\)</span>, so <span class="math inline">\(2\)</span> is a multiplicative inverse of <span class="math inline">\(8\)</span> mod <span class="math inline">\(15\)</span>. As a second example, take <span class="math inline">\(x=12\)</span> and <span class="math inline">\(m=15\)</span>. Then the sequence <span class="math inline">\(\{ax\bmod m:a=1,2,3,\ldots\}\)</span> is periodic, and takes on the values <span class="math inline">\(\{12,9,6,3,0\}\)</span> (check this!). Thus <span class="math inline">\(12\)</span> <span><em>has no multiplicative inverse mod</em></span> <span class="math inline">\(15\)</span> since the number <span class="math inline">\(1\)</span> never appears in that sequence.</p>
<p>This is the first warning sign that working in modulo arithmetic might actually be a bit different than grade-school arithmetic. Two weird things are happening. First, no multiplicative inverse seems to exist for a number that isn’t zero. In normal arithmetic, the only thing you have to worry about is dividing by zero. Second, the “times table” for a number that isn’t zero has zero showing up in it. So <span class="math inline">\(12\)</span> times <span class="math inline">\(5\)</span> is equal to zero when we are considering numbers modulo <span class="math inline">\(15\)</span>. For grade-school arithmetic, zero never shows up in the multiplication table for any number other than zero.</p>
<p>So when <span><em>does</em></span> <span class="math inline">\(x\)</span> have a multiplicative inverse modulo <span class="math inline">\(m\)</span>? The answer is: iff the greatest common divisor of <span class="math inline">\(m\)</span> and <span class="math inline">\(x\)</span> is <span class="math inline">\(1\)</span>. Moreover, when the inverse exists it is unique. Recall that the <span><em>greatest common divisor</em></span> of two natural numbers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, denoted <span class="math inline">\(\gcd(x,y)\)</span>, is the largest natural number that divides them both. For example, <span class="math inline">\(\gcd(30, 24) = 6\)</span>. If <span class="math inline">\(\gcd(x,y)\)</span> is 1, it means that <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> share no common factors (except <span class="math inline">\(1\)</span>). This is often expressed by saying that <span class="math inline">\(x\)</span> and <span class="math inline">\(m\)</span> are <span><em>relatively prime</em></span> or <span><em>coprime</em></span>.</p>
<p><span id="thm:gcd" class="pandoc-numbering-text thm"><strong>Theorem 2</strong></span></p>
<p><em>Let <span class="math inline">\(m,x\)</span> be positive integers such that <span class="math inline">\(\gcd(m,x)=1\)</span>. Then <span class="math inline">\(x\)</span> has a multiplicative inverse modulo <span class="math inline">\(m\)</span>, and it is unique (modulo <span class="math inline">\(m\)</span>).</em></p>
<p><em>Proof</em>. Consider the sequence of <span class="math inline">\(m\)</span> numbers <span class="math inline">\(0,x,2x,\ldots (m-1)x\)</span>. We claim that these are all distinct modulo <span class="math inline">\(m\)</span>. Since there are only <span class="math inline">\(m\)</span> distinct values modulo <span class="math inline">\(m\)</span>, it must then be the case that <span class="math inline">\(ax=1\bmod m\)</span> for exactly one <span class="math inline">\(a\)</span> (modulo <span class="math inline">\(m\)</span>). This <span class="math inline">\(a\)</span> is the unique multiplicative inverse.</p>
<p>To verify the above claim, suppose that <span class="math inline">\(ax \equiv bx \pmod m\)</span> for two distinct values <span class="math inline">\(a,b\)</span> in the range <span class="math inline">\(0\le b \le a\le m-1\)</span>. Then we would have <span class="math inline">\((a-b)x \equiv 0 \pmod m\)</span>, or equivalently, <span class="math inline">\((a-b)x=km\)</span> for some integer <span class="math inline">\(k\)</span> (possibly zero or negative).</p>
<p>However, <span class="math inline">\(x\)</span> and <span class="math inline">\(m\)</span> are relatively prime, so <span class="math inline">\(x\)</span> cannot share any factors with <span class="math inline">\(m\)</span>. This implies that <span class="math inline">\(a-b\)</span> must be an integer multiple of <span class="math inline">\(m\)</span>. This is not possible, since <span class="math inline">\(a-b\)</span> ranges between <span class="math inline">\(1\)</span> and <span class="math inline">\(m - 1\)</span>. <span class="math inline">\(\square\)</span></p>
<p>Actually it turns out that <span class="math inline">\(\gcd(m,x)=1\)</span> is also a <span><em>necessary</em></span> condition for the existence of an inverse: i.e., if <span class="math inline">\(\gcd(m,x)&gt;1\)</span> then <span class="math inline">\(x\)</span> has no multiplicative inverse modulo <span class="math inline">\(m\)</span>. You might like to try to prove this using a similar idea to that in the above proof. <span><em>(HINT: Think about when zeros show up in multiplication tables.)</em></span></p>
<p>Since we know that multiplicative inverses are unique when <span class="math inline">\(\gcd(m,x)=1\)</span>, we shall write the inverse of <span class="math inline">\(x\)</span> as <span class="math inline">\(x^{-1} \pmod m\)</span>, where the modulus is sometimes denoted as a subscript so <span class="math inline">\((x)^{-1}_m\)</span> can also mean the same thing. Being able to compute the multiplicative inverse of a number is crucial to many applications, so ideally the algorithm used should be efficient. It turns out that we can use an extended version of Euclid’s algorithm, which computes the GCD of two numbers, to compute the multiplicative inverse.</p>
<h2 id="computing-the-multiplicative-inverse" class="unnumbered">Computing the Multiplicative Inverse</h2>
<p>Let us first discuss how computing the multiplicative inverse of <span class="math inline">\(x\)</span> modulo <span class="math inline">\(m\)</span> is related to finding <span class="math inline">\(\gcd(x,m)\)</span>. For any pair of numbers <span class="math inline">\(x,y\)</span>, suppose we could not only compute <span class="math inline">\(\gcd(x,y)\)</span>, but also find integers <span class="math inline">\(a,b\)</span> such that <a name="eq:extEuclid"></a><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[
   d=\gcd(x,y) = ax+by.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(1)</span></span>  (Note that this is not a modular equation; and the integers <span class="math inline">\(a,b\)</span> could be zero or negative.) For example, we can write <span class="math inline">\(1=\gcd(35,12)=-1\cdot 35 + 3\cdot 12\)</span>, so here <span class="math inline">\(a=-1\)</span> and <span class="math inline">\(b=3\)</span> are possible values for <span class="math inline">\(a,b\)</span>.</p>
<p>If we could do this then we’d be able to compute inverses, as follows. We first find the integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> such that <span class="math display">\[1=\gcd(m,x) = am+bx.\]</span> But this means that <span class="math inline">\(bx \equiv 1 \pmod m\)</span>, so <span class="math inline">\(b\)</span> is the multiplicative inverse of <span class="math inline">\(x\)</span> modulo <span class="math inline">\(m\)</span>. Reducing <span class="math inline">\(b\)</span> modulo <span class="math inline">\(m\)</span> gives us the unique inverse we are looking for. In the above example, we see that <span class="math inline">\(3\)</span> is the multiplicative inverse of <span class="math inline">\(12\)</span> mod <span class="math inline">\(35\)</span>. So, we have reduced the problem of computing inverses to that of finding integers <span class="math inline">\(a,b\)</span> that satisfy Equation <a href="#eq:extEuclid">1</a>. Remarkably, Euclid’s algorithm for computing the GCD also allows us to find the integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> described above. So computing the multiplicative inverse of <span class="math inline">\(x\)</span> modulo <span class="math inline">\(m\)</span> is as simple as running Euclid’s GCD algorithm on input <span class="math inline">\(x\)</span> and <span class="math inline">\(m\)</span>!</p>
<h2 id="euclids-algorithm-for-computing-the-gcd" class="unnumbered">Euclid’s Algorithm for Computing the GCD</h2>
<p>If we wish to compute the GCD of two numbers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, how would we proceed? If <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span> is <span class="math inline">\(0\)</span>, then computing the GCD is easy; it is simply the other number, since <span class="math inline">\(0\)</span> is divisible by everything (although of course it divides nothing). The algorithm for other cases is ancient, and although associated with the name of Euclid, is almost certainly a folk algorithm invented by craftsmen (the engineers of their day) because of its intensely practical nature<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. This algorithm exists in cultures throughout the globe.</p>
<p>The algorithm for computing <span class="math inline">\(\gcd(x,y)\)</span> uses the following theorem to eventually reduce to the case where one of the numbers is <span class="math inline">\(0\)</span>:</p>
<p><span id="thm:euclid" class="pandoc-numbering-text thm"><strong>Theorem 3</strong></span></p>
<p><em>Let <span class="math inline">\(x \geq y\)</span> and let <span class="math inline">\(q, r\)</span> be natural numbers such <span class="math inline">\(x = yq + r\)</span> and <span class="math inline">\(r &lt; y\)</span>. Then <span class="math inline">\(\gcd(x,y) = \gcd(r, y)\)</span>.</em></p>
<p><em>Proof</em>. This is because any common divisor of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is also a common divisor of <span class="math inline">\(y\)</span> and <span class="math inline">\(r\)</span> and vice versa. To see this, if <span class="math inline">\(d\)</span> divides divides both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, there exist integers <span class="math inline">\(z\)</span> and <span class="math inline">\(z&#39;\)</span> such that <span class="math inline">\(zd = x\)</span> and <span class="math inline">\(z&#39;d = y\)</span>. Therefore <span class="math inline">\(r = x - yq = zd - z&#39;dq = (z - z&#39;q)d\)</span>, and so <span class="math inline">\(d\)</span> divides <span class="math inline">\(r\)</span>. The other direction follows in exactly the same way. <span class="math inline">\(\square\)</span></p>
<p>Given this theorem, let’s see how to compute <span class="math inline">\(\gcd(16,10)\)</span>:</p>
<p><span class="math inline">\(16= 10\times 1 + 6\)</span><br />
<span class="math inline">\(10= 6 \times 1 + 4\)</span><br />
<span class="math inline">\(6 = 4 \times 1 + 2\)</span><br />
<span class="math inline">\(4 = 2\times 2 + 0\)</span><br />
<span class="math inline">\(2 = 0\times 0 + 2\)</span><br />
In each line, we write the larger number <span class="math inline">\(x\)</span> as <span class="math inline">\(yq + r\)</span>, where <span class="math inline">\(y\)</span> is the smaller number. The next line then replaces the larger number with <span class="math inline">\(y\)</span>, and the smaller number with <span class="math inline">\(r\)</span>. This preserves the GCD, as shown in the theorem above. Therefore, <span class="math inline">\(\gcd(16,10) = \gcd(2,0) = 2\)</span>. Or if you wish you can stop a step earlier and say that the GCD is the last non-zero remainder: i.e. you can stop at the step <span class="math inline">\(6 = 4 \times 1 + 2\)</span>, since at the next step the remainder is <span class="math inline">\(0\)</span>.</p>
<p>This algorithm can be written recursively as follows:</p>
<pre><code>algorithm gcd(x, y)
  if y = 0 then return(x)
  else return(gcd(y, x mod y))</code></pre>
<p>Note: This algorithm assumes that <span class="math inline">\(x \geq y \geq 0\)</span> and <span class="math inline">\(x&gt;0\)</span>.</p>
<p>Let’s go through a quick example of this recursive implementation of Euclid’s algorithm. We wish to compute <span class="math inline">\(\gcd(32,10)\)</span>: <span class="math display">\[\begin{aligned}
\gcd(32,10) &amp;=&amp; \gcd(10,2) \nonumber\\
&amp;=&amp; \gcd(2,0) \nonumber\\
&amp;=&amp; 2\nonumber\end{aligned}\]</span></p>
<p><span id="thm:correct" class="pandoc-numbering-text thm"><strong>Theorem 4</strong></span></p>
<p><em>The algorithm above correctly computes the GCD of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</em></p>
<p><em>Proof</em>. Correctness is proved by (strong) induction on <span class="math inline">\(y\)</span>, the smaller of the two input numbers. For each <span class="math inline">\(y\ge 0\)</span>, let <span class="math inline">\(P(y)\)</span> denote the proposition that the algorithm correctly computes <span class="math inline">\(\gcd(x,y)\)</span> for all values of <span class="math inline">\(x\)</span> such that <span class="math inline">\(x\ge y\)</span> (and <span class="math inline">\(x&gt;0\)</span>). Certainly <span class="math inline">\(P(0)\)</span> holds, since <span class="math inline">\(\gcd(x,0)=x\)</span> and the algorithm correctly computes this in the <span>if</span>-clause. For the inductive step, we may assume that <span class="math inline">\(P(z)\)</span> holds for all <span class="math inline">\(z&lt;y\)</span> (the inductive hypothesis); our task is to prove <span class="math inline">\(P(y)\)</span>. The key observation here is that <span class="math inline">\(\gcd(x,y) = \gcd(y,x \bmod y)\)</span> — that is, replacing <span class="math inline">\(x\)</span> by <span class="math inline">\(x\bmod y\)</span> does not change the GCD. This is because a divisor <span class="math inline">\(d\)</span> of <span class="math inline">\(y\)</span> also divides <span class="math inline">\(x\)</span> if and only if it divides <span class="math inline">\(x \bmod y\)</span> (divisibility by <span class="math inline">\(d\)</span> is not affected by adding or subtracting multiples of <span class="math inline">\(d\)</span>, and <span class="math inline">\(y\)</span> <span><em>is</em></span> a multiple of <span class="math inline">\(d\)</span>). Hence the <span>else</span>-clause of the algorithm will return the correct value provided the recursive call <code>gcd(y, x mod y)</code> correctly computes the value <span class="math inline">\(\gcd(y,x\bmod y)\)</span>. But since <span class="math inline">\(x \bmod y &lt; y\)</span>, we know this is true by the inductive hypothesis. This completes our verification of <span class="math inline">\(P(y)\)</span>, and hence the induction proof. <span class="math inline">\(\square\)</span></p>
<p>How long does this algorithm take? In terms of arithmetic operations on integers, it takes time <span class="math inline">\(O(n)\)</span>, where <span class="math inline">\(n\)</span> is the total number of bits in the input <span class="math inline">\((x,y)\)</span>.</p>
<p>You should be able to see the intuitive connection to exponentiation-by-repeated-squaring. It is obvious that the arguments of the recursive calls become smaller and smaller (because <span class="math inline">\(y \le x\)</span> and <span class="math inline">\(x\bmod y &lt; y\)</span>). The question is, how fast?</p>
<p>We shall show that, in the computation of <span class="math inline">\(\gcd(x,y)\)</span>, after two recursive calls the first (larger) argument is smaller than <span class="math inline">\(x\)</span> by at least a factor of two (assuming <span class="math inline">\(x&gt;0\)</span>). There are two cases:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(y \leq x/2\)</span>. Then the first argument in the next recursive call, <span class="math inline">\(y\)</span>, is already smaller than <span class="math inline">\(x\)</span> by a factor of <span class="math inline">\(2\)</span>, and thus in the next recursive call it will be even smaller.</p></li>
<li><p><span class="math inline">\(x\geq y &gt; x/2\)</span>. Then in two recursive calls the first argument will be <span class="math inline">\(x \bmod y\)</span>, which is smaller than <span class="math inline">\(x/2\)</span>.</p></li>
</ol>
<p>So, in both cases the first argument decreases by a factor of at least two every two recursive calls. Thus after at most <span class="math inline">\(2n\)</span> recursive calls, where <span class="math inline">\(n\)</span> is the number of bits in <span class="math inline">\(x\)</span>, the recursion will stop (note that the first argument is always a natural number).</p>
<p>Note that the above argument only shows that the <span><em>number of recursive calls</em></span> in the computation is <span class="math inline">\(O(n)\)</span>. We can make the same claim for the running time if we assume that each call only requires constant time. Since each call involves one integer comparison and one mod operation, it is reasonable to claim that its running time is constant. In a more realistic model of computation, however, we should really make the time for these operations depend on the size of the numbers involved. This will be discussed in 170.</p>
<h2 id="extended-euclids-algorithm" class="unnumbered">Extended Euclid’s Algorithm</h2>
<p>In order to compute the multiplicative inverse, we need an algorithm which also returns integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> such that: <span class="math display">\[\gcd(x,y) = ax+by.\nonumber\]</span> Now since this problem is a generalization of the basic GCD, it is perhaps not too surprising that we can solve it with a fairly straightforward extension of Euclid’s algorithm.</p>
<h3 id="examples" class="unnumbered">Examples</h3>
<p>Let’s first see how we would compute such numbers for <span class="math inline">\(x = 6\)</span> and <span class="math inline">\(y = 4\)</span>. We’ll need the equations from our example above, copied here for reference:</p>
<p><span class="math inline">\(16= 10\times 1 + 6\)</span><br />
<span class="math inline">\(10= 6 \times 1 + 4\)</span><br />
<span class="math inline">\(6 = 4 \times 1 + 2\)</span><br />
<span class="math inline">\(4 = 2\times 2 + 0\)</span><br />
From the last two equations it follows that <span class="math inline">\(\gcd(6,4) = 2\)</span>. But now the second last equation gives us the numbers <span class="math inline">\(a, b\)</span>, since we just rearrange that equation to say <span class="math inline">\(2 = 6\times 1 - 4 \times 1\)</span>. So <span class="math inline">\(a = 1\)</span> and <span class="math inline">\(b = -1\)</span>.</p>
<p>What if we started with <span class="math inline">\(x = 10\)</span> and <span class="math inline">\(y = 6\)</span>? Now we would write the last three equations to determine that <span class="math inline">\(\gcd(10, 6) =2\)</span>. But how do we find <span class="math inline">\(a, b\)</span>? Start as above and write <span class="math inline">\(2 = 6\times 1 - 4 \times 1\)</span>. But we want <span class="math inline">\(10\)</span> and <span class="math inline">\(6\)</span> on the right hand side, not <span class="math inline">\(6\)</span> and <span class="math inline">\(4\)</span>. But notice that the third from the last equation allows us to write <span class="math inline">\(4\)</span> as a linear combination of <span class="math inline">\(6\)</span> and <span class="math inline">\(10\)</span> and so we can just back substitute: we rewrite that equation as <span class="math inline">\(4 = 10\times 1 - 6 \times 1\)</span> and substitute to get:<br />
<span class="math inline">\(2 = 6\times 1 - 4 \times 1 = 6\times 1 - (10\times 1 - 6 \times 1) = 6 \times 2 - 10 \times 1\)</span>.</p>
<p>If we started with <span class="math inline">\(x = 16\)</span> and <span class="math inline">\(y = 10\)</span> we would back substitute again using the first equation rewritten as <span class="math inline">\(6 = 16 - 10\)</span> to get:<br />
<span class="math inline">\(2 = 6 \times 2 - 10 \times 1 = (16 - 10) \times 2 - 10 = 16 \times 2 - 10\times 3\)</span>. So <span class="math inline">\(a = 2\)</span> and <span class="math inline">\(b = -3\)</span>.</p>
<p>To find the numbers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> described above, we can rewrite the equation as: <span class="math display">\[2 = 2 - 0\times 0\]</span> Hence <span class="math inline">\(a = 1\)</span> and <span class="math inline">\(b = 0\)</span>. What about <span class="math inline">\(\gcd(4,2)\)</span>? Now we need the last two equations. We first write <span class="math inline">\(2 = 2 - 0\times 0\)</span>, as above. The second to last equation can be rewritten as <span class="math inline">\(0 = 4 - 2\times 2\)</span>, and now we can substitute this expression for 0: <span class="math display">\[2 = 2 - 0\times 0 = 2 - 0\times(4 - 2\times 2) = 0\times 4 + 1\times 2.\]</span> We have now found <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> for <span class="math inline">\(\gcd(4,2)\)</span>: <span class="math inline">\(a=0\)</span> and <span class="math inline">\(b=1\)</span>.</p>
<p>We computed <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> by back substituting in the equations used to compute the GCD. We can continue this method for longer examples, such as computing <span class="math inline">\(\gcd(16,10)\)</span>. We first write<br />
<span class="math inline">\(2 = 0\times 4 + 1\times 2\)</span> as computed above.<br />
Now substitute <span class="math inline">\(2 = 6 - 4\times 1\)</span>:<br />
<span class="math inline">\(2 = 0\times 4 + 1 \times (6 - 4\times 1)\)</span><br />
or <span class="math inline">\(2 = 1\times 6 - 1\times 4\)</span><br />
Now substitute <span class="math inline">\(4 = 10 - 6\times 1\)</span>:<br />
<span class="math inline">\(2 = 1\times 6 - 1\times (10-6\times 1)\)</span><br />
or <span class="math inline">\(2 = -10 + 2 \times 6\)</span><br />
Now substitute <span class="math inline">\(6 = 16 - 10\times 1\)</span>:<br />
<span class="math inline">\(2 = -10 + 2\times (16 - 10\times 1)\)</span><br />
or <span class="math inline">\(2 = 2 \times 16 - 3 \times 10\)</span><br />
So <span class="math inline">\(a = 2\)</span> and <span class="math inline">\(b = -3\)</span>.</p>
<p><span class="math inline">\(2 = 6 - 4\times 1\)</span><br />
Now substitute <span class="math inline">\(4 = 10 - 6\times 1\)</span>:<br />
<span class="math inline">\(2 = 6 - (10-6\times 1)\times 1\)</span><br />
or <span class="math inline">\(2 = -10 + 6 \times 2\)</span><br />
Now substitute <span class="math inline">\(6 = 16 - 10\times 1\)</span>:<br />
<span class="math inline">\(2 = -10 + (16 - 10\times 1)\times 2\)</span><br />
or <span class="math inline">\(2 = 16 \times 2 - 10 \times 3\)</span><br />
So <span class="math inline">\(a = 2\)</span> and <span class="math inline">\(b = -3\)</span>.</p>
<h3 id="algorithm" class="unnumbered">Algorithm</h3>
<p>The following recursive algorithm <code>extended-gcd</code> implements the idea used in the examples above. It takes as input a pair of natural numbers <span class="math inline">\(x\ge y\)</span> as in Euclid’s algorithm, and returns a triple of integers <span class="math inline">\((d,a,b)\)</span> such that <span class="math inline">\(d=\gcd(x,y)\)</span> and <span class="math inline">\(d=ax+by\)</span>:</p>
<pre><code>algorithm extended-gcd(x, y)
if y = 0 then return(x, 1, 0)
else
  (d, a, b) := extended-gcd(y, x mod y)
  return((d, b, a - (x div y) * b))</code></pre>
<p>Note that this algorithm has the same form as the basic GCD algorithm we saw earlier; the only difference is that we now carry around in addition the required values <span class="math inline">\(a,b\)</span>. You should hand-turn the algorithm on the input <span class="math inline">\((x,y)=(16,10)\)</span> from our earlier example, and check that it delivers correct values for <span class="math inline">\(a,b\)</span>.</p>
<p>Let’s now look at why the algorithm works. We just need to generalize the back substitution method we used in the example above.</p>
<p>In the base case (<span class="math inline">\(y=0\)</span>), we return the GCD value <span class="math inline">\(d=x\)</span> as before, together with values <span class="math inline">\(a=1\)</span> and <span class="math inline">\(b=0\)</span> which satisfy <span class="math inline">\(ax+by=d\)</span>. If <span class="math inline">\(y&gt;0\)</span>, we first recursively compute values <span class="math inline">\((d,a,b)\)</span> such that <span class="math inline">\(d=\gcd(y, x\bmod y)\)</span> and <a name="eq:extEuclid2"></a><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[
   d=ay+b(x\bmod y).\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(2)</span></span>  Just as in our analysis of the vanilla GCD algorithm, we know that this <span class="math inline">\(d\)</span> will be equal to <span class="math inline">\(\gcd(x,y)\)</span>. So the first component of the triple returned by the algorithm is correct.</p>
<p>What about the other two components? We need to update these values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, say to <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<p>What should their values be? Well, from the specification of the algorithm, they must be integers that satisfy <a name="eq:extEuclid3"></a><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[
   d = Ax + By.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(3)</span></span>  To figure out what <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> should be, we need to rearrange Equation <a href="#eq:extEuclid2">2</a>, as follows: <span class="math display">\[\begin{aligned}
    d &amp;= ay+b(x\bmod y)\cr
    &amp;= ay + b(x - \lfloor x/y\rfloor y)\cr
    &amp;= bx + (a - \lfloor x/y\rfloor b) y.\cr
\end{aligned}\]</span> (In the second line here, we have used the fact that <span class="math inline">\(x\bmod y = x - \lfloor x/y\rfloor y\)</span> — check this!) Comparing this last equation with Equation <a href="#eq:extEuclid3">3</a>, we see that we need to take <span class="math inline">\(A=b\)</span> and <span class="math inline">\(B=a - \lfloor x/y\rfloor b\)</span>. This is exactly what the algorithm does, and this is why the algorithm works. The ideas here can be made more formal to get a full proof of correctness.</p>
<p>Since the extended GCD algorithm has exactly the same recursive structure as the vanilla version, its running time will be the same up to constant factors (reflecting the increased time per recursive call). So once again the running time on <span class="math inline">\(n\)</span>-bit numbers will be <span class="math inline">\(O(n)\)</span> arithmetic operations. This means that we can find multiplicative inverses efficiently.</p>
<h2 id="chinese-remainder-theorem" class="unnumbered">Chinese Remainder Theorem</h2>
<p>It is worth stepping back for a moment and looking at what the EGCD revealed to us. It said that the GCD could be expressed as <span class="math inline">\(ax + by\)</span> for two numbers <span class="math inline">\(x,y\)</span>. To interpret this, we can imagine the number line, starting at zero and stretching out infinitely in both directions. Imagine that we are only allowed to take steps that are either <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span> long. So, if <span class="math inline">\(x=5\)</span> and <span class="math inline">\(y=7\)</span>, then we can either move to the right or left by <span class="math inline">\(5\)</span> units or <span class="math inline">\(7\)</span> units. Suppose we start at zero, and want to know everywhere we can reach by taking a sequence of such moves.</p>
<p>Intuitively, if we can reach a number <span class="math inline">\(z\)</span>, we can reach any multiple of <span class="math inline">\(z\)</span> by simply repeating the steps it took to get to <span class="math inline">\(z\)</span> over and over again. The fact that we can execute the steps of the Euclid’s GCD algorithm tells us that anything we can reach by taking steps of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> must share all the common factors of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. This means that we can only reach any multiple of the GCD of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. The set of points that we can reach with such operations is called a “lattice” and this lattice-width interpretation of the GCD is interesting<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<p>When the GCD is <span class="math inline">\(1\)</span>, it means that we can reach all points on the integer lattice in this manner. Those who have taken linear algebra will notice a very striking intellectual “rhyme” with the ideas of a basis and span. When their GCD is <span class="math inline">\(1\)</span>, it is as though the numbers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> span all the integers<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. The Chinese Remainder Theorem (CRT) can be interpreted as a way to make this interpretation even more striking.</p>
<p>Suppose we wanted to understand all the numbers mod <span class="math inline">\(pq\)</span> where <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are relatively prime to each other. If we had to arrange these numbers onto a sheet of paper, how would we do so? Going back to elementary school, it is natural to associate a product <span class="math inline">\(pq\)</span> with a rectangle: <span class="math inline">\(p\)</span> long on one side and <span class="math inline">\(q\)</span> long on the other. So now, we know that we can place the <span class="math inline">\(pq\)</span> numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(pq - 1\)</span> on this rectangle. But how? In what order? Given a number, how can you find its “x-coordinate” as something from <span class="math inline">\(0,1,\ldots,p-1\)</span> and its “y-coordinate” as something from <span class="math inline">\(0,1,\ldots,q-1\)</span>? The natural first guess is to take a number <span class="math inline">\(z\)</span> and just compute <span class="math inline">\(z \bmod p\)</span> and <span class="math inline">\(z \bmod q\)</span> to get two “coordinates” for <span class="math inline">\(z\)</span>.</p>
<p>At this point, it is very useful to do a little exercise for yourself. Suppose <span class="math inline">\(p=3\)</span> and <span class="math inline">\(q=5\)</span> and just place all the numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(14\)</span> on this grid. You will see the coordinates as <span class="math inline">\(0 = (0,0)\)</span>, <span class="math inline">\(1 = (1,1)\)</span>, <span class="math inline">\(2= (2,2)\)</span>, <span class="math inline">\(3= (0,3)\)</span>, <span class="math inline">\(4= (1,4)\)</span>, <span class="math inline">\(5=(2,0)\)</span>, <span class="math inline">\(6= (0,1)\)</span>, <span class="math inline">\(7= (1,2)\)</span>, <span class="math inline">\(8= (2,3)\)</span>, <span class="math inline">\(9= (0,4)\)</span>, <span class="math inline">\(10=(1,0)\)</span>, <span class="math inline">\(11=(2,1)\)</span>, <span class="math inline">\(12=(0,2)\)</span>, <span class="math inline">\(13=(1,3)\)</span>, <span class="math inline">\(14=(2,4)\)</span>. When writing them out, you will see that all the numbers lie on a diagonal line that wraps around the rectangle until it fills it. Notice that no two numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(14\)</span> have the same coordinates. Furthermore, notice that doing component-wise mod <span class="math inline">\((3,5)\)</span> addition on the coordinates corresponds to doing mod <span class="math inline">\(15\)</span> addition on the numbers themselves. Perhaps more interestingly, doing component-wise mod <span class="math inline">\((3,5)\)</span> multiplication on the coordinates corresponds to doing mod <span class="math inline">\(15\)</span> multiplication on the numbers themselves. (e.g. <span class="math inline">\(3 \cdot 4 = 12\)</span> and <span class="math inline">\((0,3) \cdot (1,4) \equiv (0,2)\)</span>). This means that operations can be equivalently performed component-wise in the tuple-representation.</p>
<p>Furthermore, we notice that there are two special tuples <span class="math inline">\((1,0)=10\)</span> and <span class="math inline">\((0,1)=6\)</span>. The corresponding numbers act like “orthonormal basis elements” do in linear algebra. They provide an easy way to map from coordinates back to numbers. So <span class="math inline">\((a,b)\)</span> in coordinates represents the same number as <span class="math inline">\(10a + 6b \bmod 15\)</span>. For example, <span class="math inline">\((2,1) \rightarrow 20 + 6 = 26 \equiv 11 \pmod{15}\)</span>. So, not only can we easily move from numbers to coordinates (by just taking mods), we can also easily move from coordinates to numbers (by using these special basis elements). Before we state the general form of the Chinese Remainder Theorem, it is useful to observe that the basis element <span class="math inline">\(10\)</span> corresponding the first coordinate (obtained by modding by <span class="math inline">\(3\)</span>) is a multiple of the other modulus <span class="math inline">\(5\)</span>. This has to be true because its representation in coordinates is designed to have a zero in that other coordinate. Similarly, <span class="math inline">\(6\)</span> corresponds to the second coordinate (obtained by modding by <span class="math inline">\(5\)</span>) and is a multiple of <span class="math inline">\(3\)</span>.</p>
<p>With this example in hand, we are ready to generalize and to state the result more formally.</p>
<p><span id="thm:crt" class="pandoc-numbering-text thm"><strong>Theorem 5</strong> <em>(Chinese Remainder Theorem)</em></span></p>
<p><em>Let <span class="math inline">\(n_1, n_2, \ldots, n_k\)</span> be positive integers that are coprime to each other. Then, for any sequence of integers <span class="math inline">\(a_i\)</span> there is a unique integer <span class="math inline">\(x\)</span> between <span class="math inline">\(0\)</span> and <span class="math inline">\(\prod_{i=1}^{k} n_i\)</span> that satisfies the congruences:</em> <span class="math display">\[\begin{aligned}
 x &amp; \equiv a_1 \pmod{n_1} \\
&amp; \vdots \\
x &amp; \equiv a_i \pmod{n_i} \\
&amp; \vdots \\
 x &amp; \equiv a_k \pmod{n_k} \end{aligned}\]</span> <em>Moreover this integer <span class="math inline">\(x\)</span> can be found:</em> <span class="math display">\[x = \left(\sum_{i=1}^k a_i b_i\right)  \bmod N\]</span> <em>where <span class="math inline">\(N = \prod_{i=1}^{k} n_i\)</span> and the “basis” numbers <span class="math inline">\(b_i\)</span> are found using the formula <span class="math inline">\(b_i = (N/n_i) (N/n_i)^{-1}_{n_i}\)</span> where <span class="math inline">\((N/n_i)^{-1}_{n_i}\)</span> denotes the multiplicative inverse (mod <span class="math inline">\(n_i\)</span>) of the integer <span class="math inline">\(N/n_i\)</span>.</em></p>
<p><em>Proof</em>. The only question in being able to apply the formulas is to make sure that <span class="math inline">\((N/n_i)^{-1}_{n_i}\)</span> exists. To verify this, we first notice that <span class="math inline">\(N/n_i = \prod_{j\neq i} n_j\)</span> is a nonzero integer that is coprime to <span class="math inline">\(n_i\)</span> since by construction, they can share no common factors. So the multiplicative inverse exists. This means that the formula is indeed computable and because it involves modding by <span class="math inline">\(N\)</span>, it clearly gives rise to an <span class="math inline">\(x\)</span> between <span class="math inline">\(0\)</span> and <span class="math inline">\(N-1\)</span>.</p>
<p>To see that this <span class="math inline">\(x\)</span> solves the system of congruences, we need to take <span class="math inline">\(x \bmod n_i\)</span> and see what happens. First notice that <span class="math inline">\(N/n_r = \prod_{j\neq r} n_j\)</span> is congruent to <span class="math inline">\(0\)</span> when we mod by <span class="math inline">\(n_i \neq n_r\)</span>. This means that: <span class="math display">\[\begin{aligned}
x \bmod n_i 
&amp;=   \left(\left(\sum_{i=1}^k a_i b_i\right)  \bmod N\right) \bmod n_i \\
&amp;=   \left(\sum_{i=1}^k a_i b_i\right)  \bmod n_i \\
&amp;=   a_i b_i \bmod n_i \\
&amp;=   a_i \left(\frac{N}{n_i} \left(\frac{N}{n_i}\right)^{-1}_{n_i}\right) \bmod n_i \\
&amp;=   a_i \bmod n_i\end{aligned}\]</span> where the last quality used the definition of multiplicative inverse and the second equality used the fact that modding by a product and then by one of terms in that product is the same as just modding by that single term.</p>
<p>The above establishes that <span class="math inline">\(x \equiv a_i \pmod{n_i}\)</span> and so <span class="math inline">\(x\)</span> does indeed solve the system of congruences. To see that it is unique, we have two arguments that we could use. The simplest argument is by counting. There are <span class="math inline">\(N = \prod_{i=1}^k n_i\)</span> possible values for the <span class="math inline">\((a_1, a_2, \ldots, a_k)\)</span> tuples and the <span class="math inline">\(N\)</span> numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(N-1\)</span> each land in exactly one of these. If two landed in one bin, then that means that another bin must be empty. But we can construct an <span class="math inline">\(x\)</span> corresponding to that bin and so it cannot be empty. This means that there must be a bijection from the coordinate tuples <span class="math inline">\((a_1, a_2, \ldots, a_k)\)</span> and the <span class="math inline">\(N\)</span> numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(N-1\)</span>.</p>
<p>Alternatively, suppose that some <span class="math inline">\(y\)</span> also solves these congruences. Consider <span class="math inline">\(z=y-x\)</span>. Clearly <span class="math inline">\(z \bmod n_i\)</span> is zero for all the <span class="math inline">\(n_i\)</span>. This means that <span class="math inline">\(z\)</span> is a multiple of <span class="math inline">\(n_i\)</span> for each <span class="math inline">\(i\)</span> and since they are all coprime, <span class="math inline">\(z\)</span> is a multiple of <span class="math inline">\(N\)</span>, their product. But the difference of two numbers ranging from <span class="math inline">\(0\)</span> to <span class="math inline">\(N-1\)</span> must have an absolute value of at most <span class="math inline">\(N-1\)</span>. This means that the only multiple of <span class="math inline">\(N\)</span> that <span class="math inline">\(z\)</span> can be is <span class="math inline">\(0\)</span>. This means that <span class="math inline">\(y=x\)</span> and so indeed, the given solution is unique. <span class="math inline">\(\square\)</span></p>
<p>The Chinese Remainder Theorem (CRT) is a very powerful tool since it lets us move between numbers and their coordinates for the purpose of doing computations. Although stated for moduli that are all coprime, it can be extended to moduli <span class="math inline">\(n_i\)</span> that are not coprime. However, in those cases, one has to be more careful. First, the range of numbers that we are interested in now is the Least-Common-Multiple (LCM) of the <span class="math inline">\(n_i\)</span> values. Second, we must beware of inconsistent congruences. For example, we cannot simultaneously be congruent to <span class="math inline">\(1 \pmod 2\)</span> and be congruent to <span class="math inline">\(2 \pmod 6\)</span>. In general, <span class="math inline">\(a_i \equiv a_j \pmod{\gcd(n_i,n_j)}\)</span> must hold for a pair of congruences to be consistent<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. You might be tempted to just use the formulas above with <span class="math inline">\(N = \operatorname{LCM}(n_1, n_2, \ldots, n_k)\)</span>, but that is not quite enough<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<p>The homework has problems that will help you discover for yourself how the CRT can be very useful in solving problems.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You can analyze grade-school long-division for binary numbers to understand how long a mod operation would take.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Inverting exponentiation uses logarithms in the real numbers. The discrete logarithm is currently essentially impossible to compute efficiently. So we will not be talking about it.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>This algorithm is used for figuring out a common unit of measurement for two lengths. You can imagine how this is extremely important for building something up from a scale model. Different lengths in a design can be expressed as integer multiples of a common length, and then a new measuring stick can be found for the scaled-up design. We will see how the algorithm itself can be executed without literacy or symbolic notation. It is fundamentally <span><em>physical</em></span> in its intuition and you should figure out how this can be executed using threads. In the homework, you will see how this algorithm reveals the secret hidden in plain sight within the Pentagram.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>This interpretation also makes short work of the classic family of puzzles of the form “you have a <span class="math inline">\(5\)</span> oz cup and a <span class="math inline">\(7\)</span> oz cup, an infinite reservoir of water, and a unlimited size mixing bowl. Can you manage to pour exactly <span class="math inline">\(z\)</span> oz of water into a jar?” Do you see how such puzzles can be solved using EGCD?<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>And when the GCD is <span class="math inline">\(2\)</span>, we can reach all even numbers. The even numbers behave in a way analogous to a subspace in linear algebra.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Since we can just mod both sides of both congruences by the GCD of <span class="math inline">\(n_i\)</span> and <span class="math inline">\(n_j\)</span> to get a congruence mod the GCD. If these two disagree, then the system of equations is clearly inconsistent.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Instead, you can proceed by turning all congruences into statements about remainders mod prime powers. For every congruence that involves a composite modulus, just replace it with the equivalent system of congruences in terms of the prime-power factors of the modulus. By the regular CRT, these are equivalent to the original congruence. Once this has been applied to all the congruences, you simply have to discard redundant information. The rule is simple: keep only the congruence involving the largest power of any given prime. All the congruences for smaller powers are redundant. At this point, you have expressed the original congruences into a set of canonical congruences in terms of the prime factorization of the LCM of the original moduli.<a href="#fnref7">↩</a></p></li>
</ol>
</div>
</article>
</body>

<!-- Mirrored from www.eecs70.org/static/notes/n6.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 May 2018 00:39:22 GMT -->
</html>
