<!DOCTYPE html>
<!--==============================================================================
	           "GitHub HTML5 Pandoc Template" v1.2 — by Tristano Ajmone           
	==============================================================================
	(c) Tristano Ajmone, 2017, MIT License (MIT). Project's home repository:

	- https://github.com/tajmone/pandoc-goodies

	This template reuses source code taken from the following projects:

	- GitHub Markdown CSS: © Sindre Sorhus, MIT License (MIT):
	  https://github.com/sindresorhus/github-markdown-css

	- Primer CSS: © 2016 GitHub Inc., MIT License (MIT):
	  http://primercss.io/
	==============================================================================-->
<html>

<!-- Mirrored from www.eecs70.org/static/notes/n9.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 May 2018 00:39:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Error-Correcting Codes</title>
<style type="text/css">@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff')}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5;word-wrap:break-word;box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects;color:#0366d6;text-decoration:none}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body h1{margin:.67em 0}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #dfe2e5}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:100%;overflow:auto}.markdown-body td,.markdown-body th{padding:0}.markdown-body blockquote{margin:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.markdown-body pre{font:12px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;word-wrap:normal}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{font-size:11px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#6a737d}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:"\00a0"}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fcfcfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.flash{position:relative;padding:16px;color:#246;background-color:#e2eef9;border:1px solid #bac6d3;border-radius:3px}.flash p:last-child{margin-bottom:0}.flash-messages{margin-bottom:24px}.flash-warn{color:#4c4a42;background-color:#fff9ea;border-color:#dfd8c2}.flash-error{color:#911;background-color:#fcdede;border-color:#d2b2b2}.flash-success{color:#22662c;background-color:#e2f9e5;border-color:#bad3be}.flash-plain{color:#4c4a42;background-color:#f5f5f5;border-color:#c1c1c1}.figure{text-align:center;}</style>
  <style type="text/css">code{white-space: pre;}</style>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {equationNumbers: {autoNumber: "AMS"}}
    });
  </script>
  <script src="../../../cdn.mathjax.org/mathjax/latest/MathJax2ba6.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<article class="markdown-body">
<header>
<h1 class="title">Error-Correcting Codes</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#error-correcting-codes">Error-Correcting Codes</a><ul>
<li><a href="#erasure-errors">Erasure Errors</a><ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#polynomial-interpolation">Polynomial Interpolation</a></li>
<li><a href="#general-errors">General Errors</a><ul>
<li><a href="#example-1">Example</a></li>
<li><a href="#finer-points-regarding-berlekamp-welch">Finer Points Regarding Berlekamp-Welch</a></li>
</ul></li>
<li><a href="#distance-properties">Distance Properties</a><ul>
<li><a href="#the-distance-properties-of-reed-solomon-codes">The Distance Properties of Reed-Solomon Codes</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="error-correcting-codes">Error-Correcting Codes</h1>
<p>We will consider two situations in which we wish to convey information on an unreliable channel. The first is exemplified by the internet, where the information (say a file) is broken up into packets, and the unreliability is manifest in the fact that some of the packets are lost (or erased) during transmission. Moreover the packets are labeled with headers so that the recipient knows exactly which packets were received and which were dropped. We will refer to such errors as erasure errors. See the figure below:</p>
<div class="figure">
<img src="n9-erasure.png" style="width:50.0%" />

</div>
<p>In the second situation, some of the packets are corrupted during transmission due to channel noise. Now the recipient has no idea which packets were corrupted and which were received unmodified:</p>
<div class="figure">
<img src="n9-general.png" style="width:50.0%" />

</div>
<p>In the above example, packets <span class="math inline">\(1\)</span> and <span class="math inline">\(4\)</span> are corrupted. These types of errors are called general errors. We will discuss methods of encoding messages, called error-correcting codes, which are capable of correcting both erasure and general errors. The principle is to embed a message into a codeword (a process called encoding), transmit the codeword, and then recover the message from the damaged/corrupted symbols that are received (a process called decoding).</p>
<p>This area of study is a part of “Information Theory,” one of the core computer sciences<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> along with the theory of computation, control theory, communication theory, and estimation/learning theory. At the National Science Foundation, these are (largely) currently in the Computer and Information Science and Engineering (CISE) directorate in the Division of Computing and Communication Foundations (CCF). In particular, there is a rich area of coding theory and here in this note, we will simply touch a little part of it. If you want to learn more, this material is built upon in 121, 229A, 229B, and other courses.</p>
<p>On the practical side, this material is intensely useful. Every time you use your cellphone, satellite TV, DSL, cable-modem, hard-disk drive, solid-state drive, CD-ROM, DVD, Blu-ray, etc., error-correcting codes are crucial. Related ideas are being deployed in the Internet for streaming and in modern data-centers to make cloud computing and distributed storage possible. Perhaps most surprisingly, the actual (polynomial-based) codes that you are studying in this lecture notes are called Reed-Solomon<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> codes and are essentially what are used in many applications. These are representative of what are called algebraic-geometry codes, because of their connections to algebraic geometry — the branch of mathematics that studies the roots of polynomial equations.</p>
<p>Returning to the problem at hand. Assume that the information consists of <span class="math inline">\(n\)</span> packets<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> . We can assume without loss of generality that the contents of each packet is a number modulo <span class="math inline">\(q\)</span> (denoted by <span class="math inline">\(\operatorname{GF}(q)\)</span>), where <span class="math inline">\(q\)</span> is a prime. For example, the contents of the packet might be a <span class="math inline">\(32\)</span>-bit string and can therefore be regarded as a number between <span class="math inline">\(0\)</span> and <span class="math inline">\(2^{32} -1\)</span>; then we could choose <span class="math inline">\(q\)</span> to be any prime<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> larger than <span class="math inline">\(2^{32}\)</span>. The properties of polynomials over <span class="math inline">\(\operatorname{GF}(q)\)</span> (i.e., with coefficients and values reduced modulo <span class="math inline">\(q\)</span>) are the backbone of both error-correcting schemes. To see this, let us denote the message to be sent by <span class="math inline">\(m_1 , \ldots, m_n\)</span> and make the following crucial observations:</p>
<p><span><strong>1)</strong></span> There is a unique polynomial <span class="math inline">\(P(x)\)</span> of degree <span class="math inline">\(n - 1\)</span> such that <span class="math inline">\(P(i) = m_i\)</span> for <span class="math inline">\(1 \leq i \leq n\)</span> (i.e., <span class="math inline">\(P(x)\)</span> contains all of the information about the message, and evaluating <span class="math inline">\(P(i)\)</span> gives the intended contents of the <span class="math inline">\(i\)</span>-th packet).</p>
<p><span><strong>2)</strong></span> The message to be sent is now <span class="math inline">\(m_1 = P(1), \ldots, m_n = P(n)\)</span>. We can generate additional packets by evaluating <span class="math inline">\(P(x)\)</span> at additional points <span class="math inline">\(n+1, n+2, \ldots, n+j\)</span> (remember, our transmitted codeword must be redundant, i.e., it must contain more packets than the original message to account for the lost or corrupted packets). Thus the transmitted codeword is <span class="math inline">\(c_1 = P(1) , c_2 = P(2) , \ldots , c_{n+j} = P(n+j)\)</span>. (Alternatively, we can use the <span class="math inline">\(n\)</span> numbers defining the message as the coefficients of a degree <span class="math inline">\(n-1\)</span> polynomial directly. Either way, the transmitted codeword will be evaluations of this polynomial.) Since we are working modulo <span class="math inline">\(q\)</span>, we must make sure that <span class="math inline">\(n + j \leq q\)</span>, but this condition does not impose a serious constraint since <span class="math inline">\(q\)</span> is presumed to be very large.</p>
<h2 id="erasure-errors" class="unnumbered">Erasure Errors</h2>
<p>Here we consider the setting of packets being sent over the internet. In this setting, the packets are labeled and so the recipient knows exactly which packets were dropped during transmission. One additional observation will be useful:</p>
<p><span><strong>3)</strong></span> By <a href="n8.html#prop:prop2">Property 2</a>, we can uniquely reconstruct <span class="math inline">\(P(x)\)</span> from its values at any <span class="math inline">\(n\)</span> distinct points, since it has degree <span class="math inline">\(n-1\)</span>. This means that <span class="math inline">\(P(x)\)</span> can be reconstructed from any <span class="math inline">\(n\)</span> of the transmitted packets. Evaluating this reconstructed polynomial <span class="math inline">\(P(x)\)</span> at <span class="math inline">\(x = 1, \ldots , n\)</span> yields the original message <span class="math inline">\(m_1 , \ldots , m_n\)</span>. (Or alternatively, if the message was encoded into the polynomial’s coefficients, we could just read the message out by simplifying the polynomial.)</p>
<p>Recall that in our scheme, the transmitted codeword is <span class="math inline">\(c_1 = P(1) , c_2 = P(2) , \ldots , c_{n+j} = P(n+j)\)</span>. Thus, if we hope to be able to correct <span class="math inline">\(k\)</span> errors, we simply need to set <span class="math inline">\(j= k\)</span>. The encoded codeword will then consist of <span class="math inline">\(n + k\)</span> packets.</p>
<h3 id="example" class="unnumbered">Example</h3>
<p>Suppose Alice wants to send Bob a message of <span class="math inline">\(n=4\)</span> packets and she wants to guard against <span class="math inline">\(k=2\)</span> lost packets. Then, assuming the packets can be coded up as integers between <span class="math inline">\(0\)</span> and <span class="math inline">\(6\)</span>, Alice can work over <span class="math inline">\(\operatorname{GF}(7)\)</span> (since <span class="math inline">\(7\ge n+k = 6\)</span>). Suppose the message that Alice wants to send to Bob is <span class="math inline">\(m_1 = 3\)</span>, <span class="math inline">\(m_2 = 1\)</span>, <span class="math inline">\(m_3 = 5\)</span>, and <span class="math inline">\(m_4 = 0\)</span>. She interpolates to find the unique polynomial of degree <span class="math inline">\(n - 1 = 3\)</span> described by these 4 points: <span class="math inline">\(P(x) = x^3 + 4x^2 + 5\)</span> (verify that <span class="math inline">\(P(i) = m_i\)</span> for <span class="math inline">\(1 \leq i \leq 4\)</span>).</p>
<p>Since <span class="math inline">\(k=2\)</span>, Alice must evaluate <span class="math inline">\(P(x)\)</span> at <span class="math inline">\(2\)</span> extra points: <span class="math inline">\(P(5) = 6\)</span> and <span class="math inline">\(P(6) = 1\)</span>. Now, Alice can transmit the encoded codeword which consists of <span class="math inline">\(n + k = 6\)</span> packets, where <span class="math inline">\(c_j = P(j)\)</span> for <span class="math inline">\(1\leq j \leq 6\)</span>. So <span class="math inline">\(c_1 = P(1) = 3\)</span>, <span class="math inline">\(c_2 = P(2) = 1\)</span>, <span class="math inline">\(c_3 = P(3) = 5\)</span>, <span class="math inline">\(c_4 = P(4) = 0\)</span>, <span class="math inline">\(c_5 = P(5) = 6\)</span>, and <span class="math inline">\(c_6 = P(6) = 1\)</span>. Suppose packets <span class="math inline">\(2\)</span> and <span class="math inline">\(6\)</span> are dropped, in which case we have the following situation:</p>
<div class="figure">
<img src="n9-packets0.png" style="width:50.0%" />

</div>
<p>From the values that Bob received (<span class="math inline">\(3\)</span>, <span class="math inline">\(5\)</span>, <span class="math inline">\(0\)</span>, and <span class="math inline">\(6\)</span>), he uses Lagrange interpolation and computes the following delta functions: <span class="math display">\[\begin{aligned}
\Delta_1(x) &amp;= \frac{(x - 3)(x - 4)(x - 5)}{-24}\\
\Delta_3(x) &amp;= \frac{(x - 1)(x - 4)(x - 5)}{4}\\
\Delta_4(x) &amp;= \frac{(x - 1)(x - 3)(x - 5)}{-3}\\
\Delta_5(x) &amp;= \frac{(x - 1)(x - 3)(x - 4)}{8}.\end{aligned}\]</span> He then reconstructs the polynomial <span class="math inline">\(P(x) = (3)\Delta_1(x)+(5)\Delta_3(x)+(0)\Delta_4(x) + (6)\Delta_5(x) = x^3 + 4x^2 + 5\)</span>. Bob then evaluates <span class="math inline">\(m_2 = P(2) = 1\)</span>, which is the packet that was lost from the original codeword. More generally, no matter which two packets were dropped, following the same method Bob could still have reconstructed <span class="math inline">\(P(x)\)</span> and thus the original message.</p>
<p>Let us consider what would happen if Alice sent one fewer packet. If Alice only sent <span class="math inline">\(c_j\)</span> for <span class="math inline">\(1 \leq j \leq n + k - 1\)</span>, then with <span class="math inline">\(k\)</span> erasures, Bob would only receive <span class="math inline">\(c_j\)</span> for <span class="math inline">\(n - 1\)</span> distinct values <span class="math inline">\(j\)</span>. Thus, Bob would not be able to reconstruct <span class="math inline">\(P(x)\)</span> (since there are exactly <span class="math inline">\(q\)</span> polynomials of degree at most <span class="math inline">\(n - 1\)</span> that agree with the <span class="math inline">\(n - 1\)</span> packets which Bob received). This error-correcting scheme is therefore optimal: it can recover the <span class="math inline">\(n\)</span> characters of the message from any <span class="math inline">\(n\)</span> received characters, but recovery from any fewer characters is impossible.</p>
<h2 id="polynomial-interpolation" class="unnumbered">Polynomial Interpolation</h2>
<p>Let us take a brief digression to discuss another method of polynomial interpolation which will be useful in handling general errors. The goal of the algorithm will be to take as input <span class="math inline">\(d+1\)</span> pairs <span class="math inline">\((x_1,y_1),\ldots,(x_{d+1},y_{d+1})\)</span>, and output the polynomial <span class="math inline">\(p(x) = a_dx^d + \cdots + a_1x + a_0\)</span> such that <span class="math inline">\(p(x_i) = y_i\)</span> for <span class="math inline">\(i = 1\)</span> to <span class="math inline">\(d+1\)</span>.</p>
<p>The first step of the algorithm is to write a system of <span class="math inline">\(d+1\)</span> linear equations in <span class="math inline">\(d+1\)</span> variables: the coefficients of the polynomial <span class="math inline">\(a_0, \ldots, a_d\)</span>. Each equation is obtained by fixing <span class="math inline">\(x\)</span> to be one of <span class="math inline">\(d+1\)</span> values: <span class="math inline">\(x_1,\ldots,x_{d+1}\)</span>. Note that in <span class="math inline">\(p(x)\)</span>, <span class="math inline">\(x\)</span> is a variable and <span class="math inline">\(a_0,\dots,a_d\)</span> are fixed constants. In the equations below, these roles are swapped: <span class="math inline">\(x_i\)</span> is a fixed constant and <span class="math inline">\(a_0,\dots,a_d\)</span> are variables. For example, the <span class="math inline">\(i\)</span>-th equation is the result of fixing <span class="math inline">\(x\)</span> to be <span class="math inline">\(x_i\)</span>: <span class="math inline">\(a_d x_i^d + a_{d-1} x_i^{d-1} + \cdots + a_0 = y_i\)</span>.</p>
<p>Now solving these equations gives the coefficients of the polynomial <span class="math inline">\(p(x)\)</span>. For example, given the <span class="math inline">\(3\)</span> pairs <span class="math inline">\((-1,2)\)</span>, <span class="math inline">\((0,1)\)</span>, and <span class="math inline">\((2,5)\)</span>, we will construct the degree <span class="math inline">\(2\)</span> polynomial <span class="math inline">\(p(x)\)</span> which goes through these points. The first equation says <span class="math inline">\(a_2(-1)^2 + a_1(-1) + a_0 = 2\)</span>. Simplifying, we get <span class="math inline">\(a_2 - a_1 + a_0 = 2\)</span>. Similarly, the second equation says <span class="math inline">\(a_2(0)^2 + a_1(0) + a_0 = 1\)</span>, or <span class="math inline">\(a_0 = 1\)</span>. And the third equation says <span class="math inline">\(a_2(2)^2 + a_1(2) + a_0 = 5\)</span>. So we get the following system of equations: <span class="math display">\[\begin{aligned}
a_2 - a_1 + a_0 &amp;= 2\\
a_0 &amp;= 1\\
4a_2 + 2a_1 + a_0 &amp;= 5\end{aligned}\]</span> Substituting for <span class="math inline">\(a_0\)</span> and multiplying the first equation by <span class="math inline">\(2\)</span> we get: <span class="math display">\[\begin{aligned}
2a_2 - 2a_1 &amp;= 2\\
4a_2 + 2a_1 &amp;= 4\end{aligned}\]</span> Then, adding the two equations we find that <span class="math inline">\(6a_2 = 6\)</span>, so <span class="math inline">\(a_2 = 1\)</span>, and plugging back in we find that <span class="math inline">\(a_1 = 0\)</span>. Thus, we have determined the polynomial <span class="math inline">\(p(x) = x^2 + 1\)</span>. To justify this method more carefully, we must show that the equations always have a solution and that it is unique. This involves showing that a certain determinant is non-zero, which we will leave as an exercise<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<h2 id="general-errors" class="unnumbered">General Errors</h2>
<p>Now let us return to general errors. General errors are much more challenging to correct than erasure errors. This is because packets are corrupted, not erased and Bob no longer knows which packets are correct. As we shall see shortly, Alice can still guard against <span class="math inline">\(k\)</span> general errors, at the expense of transmitting only <span class="math inline">\(2k\)</span> additional packets or characters (only twice as many as in the erasure case). Thus the encoded codeword is <span class="math inline">\(c_1, \ldots, c_{n+2k}\)</span> where <span class="math inline">\(c_j = P(j)\)</span> for <span class="math inline">\(1 \leq j \leq n + 2k\)</span>. This means that at least <span class="math inline">\(n+k\)</span> of these characters are received uncorrupted by Bob.</p>
<p>For example, if Alice wishes to send <span class="math inline">\(n = 4\)</span> characters to Bob via a modem in which <span class="math inline">\(k = 1\)</span> of the characters is corrupted, she must redundantly send a codeword consisting of 6 characters. Suppose she wants to convey the same message as above, and that <span class="math inline">\(c_1\)</span> is corrupted and changed to <span class="math inline">\(r_1 = 2\)</span>. This scenario can be visualized in the following figure:</p>
<div class="figure">
<img src="n9-packets3.jpg" style="width:50.0%" />

</div>
<p>Bob’s goal is to reconstruct <span class="math inline">\(P(x)\)</span> from the <span class="math inline">\(n+2k\)</span> received symbols <span class="math inline">\(r_1,\ldots,r_{n+2k}\)</span>. He knows that <span class="math inline">\(P(i)\)</span> must equal <span class="math inline">\(r_i\)</span> on at least <span class="math inline">\(n+k\)</span> points (since only <span class="math inline">\(k\)</span> points are corrupted), but he does not know which of the <span class="math inline">\(n+k\)</span> values are correct. As an example, consider a possible scenario depicted in the picture below. The points represent the symbols received from Alice, and the line represents <span class="math inline">\(P(x)\)</span>. In this example, <span class="math inline">\(n = 3\)</span>, <span class="math inline">\(k = 1\)</span>, and the third packet is corrupted. Bob does not know the index at which the received symbols and the polynomial deviate:</p>
<div class="figure">
<img src="n9-generalex.png" style="width:50.0%" />

</div>
<p>Bob attempts to construct <span class="math inline">\(P(x)\)</span> by searching for a polynomial <span class="math inline">\(P&#39;(x)\)</span> with the following property: <span class="math inline">\(P&#39;(i) = r_i\)</span> for at least <span class="math inline">\(n+k\)</span> distinct values of <span class="math inline">\(i\)</span> between <span class="math inline">\(1\)</span> and <span class="math inline">\(n+2k\)</span>. Of course, <span class="math inline">\(P(x)\)</span> is one such polynomial. It turns out<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> that <span class="math inline">\(P(x)\)</span> is actually the only polynomial with the desired property. Therefore, <span class="math inline">\(P&#39;(x)\)</span> must equal <span class="math inline">\(P(x)\)</span>.</p>
<p>Finding <span class="math inline">\(P(x)\)</span> efficiently requires a remarkable idea, which is just about simple enough to be described here. Suppose packets <span class="math inline">\(e_1,\dots,e_k\)</span> are corrupted. Define the degree <span class="math inline">\(k\)</span> polynomial <span class="math inline">\(E(x)\)</span> to be <span class="math inline">\((x-e_1)\cdots(x-e_k)\)</span>. Let us make a simple but crucial observation: <span class="math display">\[P(i)E(i) = r_iE(i) \mbox{ for }1 \leq i \leq n+2k\]</span> (this is true at points <span class="math inline">\(i\)</span> at which no error occurred since <span class="math inline">\(P(i) = r_i\)</span>, and trivially true at points <span class="math inline">\(i\)</span> at which an error occurred since <span class="math inline">\(E(i) = 0\)</span>).</p>
<p>This observation forms the basis of a very clever algorithm invented by Berlekamp and Welch. Looking more closely at these equalities, we will show that they can be cast as <span class="math inline">\(n+2k\)</span> linear equations in <span class="math inline">\(n+2k\)</span> unknowns. The unknowns correspond to the coefficients of <span class="math inline">\(E(x)\)</span> and <span class="math inline">\(Q(x)\)</span> (where we define <span class="math inline">\(Q(x) = P(x)E(x)\)</span>). Once <span class="math inline">\(Q(x)\)</span> and <span class="math inline">\(E(x)\)</span> are known, we can divide <span class="math inline">\(Q(x)\)</span> by <span class="math inline">\(E(x)\)</span> to obtain <span class="math inline">\(P(x)\)</span>.</p>
<p>Since <span class="math inline">\(Q(x)\)</span> is a polynomial of degree <span class="math inline">\(n+k-1\)</span>, it can be described by <span class="math inline">\(n+k\)</span> coefficients. <span class="math inline">\(E(x)\)</span> is a degree <span class="math inline">\(k\)</span> polynomial, but its definition implies that its first coefficient must be <span class="math inline">\(1\)</span>. It can therefore be described by <span class="math inline">\(k\)</span> coefficients: <span class="math display">\[\begin{aligned}
Q(x) = a_{n+k-1}x^{n+k-1} + \cdots + a_1x + a_0 \\
E(x) = x^k + b_{k-1}x^{k-1} + \cdots + b_1x + b_0\end{aligned}\]</span> As seen in the interpolation method above, once we fix a value <span class="math inline">\(i\)</span> for <span class="math inline">\(x\)</span>, <span class="math inline">\(Q(i)\)</span> and <span class="math inline">\(E(i)\)</span> are linear functions of the unknown coefficients <span class="math inline">\(a_{n+k-1},\cdots,a_0\)</span> and <span class="math inline">\(b_{k-1},\cdots,b_0\)</span> respectively. The received value <span class="math inline">\(r_i\)</span> is also fixed. Therefore the equation <span class="math inline">\(Q(i) = r_iE(i)\)</span> is a linear equation in the <span class="math inline">\(n+2k\)</span> unknowns <span class="math inline">\(a_{n+k-1}, \ldots, a_0\)</span> and <span class="math inline">\(b_{k-1}, \ldots, b_0\)</span>. We thus have at least <span class="math inline">\(n+2k\)</span> linear equations, one for each value of <span class="math inline">\(i\)</span>, and <span class="math inline">\(n+2k\)</span> unknowns. We can solve these equations and get <span class="math inline">\(E(x)\)</span> and <span class="math inline">\(Q(x)\)</span>. We can then compute the ratio <span class="math inline">\(Q(x)/E(x)\)</span> to obtain <span class="math inline">\(P(x)\)</span>.</p>
<h3 id="example-1" class="unnumbered">Example</h3>
<p>Suppose we are working over <span class="math inline">\(\operatorname{GF}(7)\)</span> and Alice wants to send Bob the <span class="math inline">\(n = 3\)</span> characters “<span class="math inline">\(3\)</span>”, “<span class="math inline">\(0\)</span>”, and “<span class="math inline">\(6\)</span>” over a modem. Turning to the analogy of the English alphabet, this is equivalent to using only the first <span class="math inline">\(7\)</span> letters of the alphabet, where <span class="math inline">\(a = 0, \ldots, g = 6\)</span>. So the message which Alice wishes for Bob to receive is “dag”. Then Alice interpolates to find the polynomial <span class="math display">\[P(x) = x^2 + x + 1,\]</span> which is the unique polynomial of degree <span class="math inline">\(2\)</span> such that <span class="math inline">\(P(1) = 3\)</span>, <span class="math inline">\(P(2) = 0\)</span>, and <span class="math inline">\(P(3) = 6\)</span>.</p>
<p>She needs to transmit the codeword consisting of <span class="math inline">\(n + 2k = 5\)</span> characters <span class="math inline">\(P(1) = 3\)</span>, <span class="math inline">\(P(2) = 0\)</span>, <span class="math inline">\(P(3) = 6\)</span>, <span class="math inline">\(P(4) = 0\)</span>, and <span class="math inline">\(P(5) = 3\)</span> to Bob. Suppose <span class="math inline">\(P(1)\)</span> is corrupted, so he receives <span class="math inline">\(2\)</span> instead of <span class="math inline">\(3\)</span> (i.e., Alice sends the encoded codeword “dagad” but Bob instead receives “cagad”). Summarizing, we have the following situation:</p>
<p>Let <span class="math inline">\(E(x) = x + b_0\)</span> be the error-locator polynomial—remember, Bob doesn’t know what <span class="math inline">\(b_0\)</span> is yet since he doesn’t know where the (single) error occurred. Let <span class="math inline">\(Q(x) = a_3x^3 + a_2x^2 + a_1x + a_0\)</span>. Now Bob just substitutes <span class="math inline">\(x = 1, x = 2, \dotsc, x = 5\)</span> into <span class="math inline">\(Q(x) = r_xE(x)\)</span> and simplifies to get five linear equations in five unknowns. Recall that we are working modulo <span class="math inline">\(7\)</span> and that <span class="math inline">\(r_i = c_i&#39;\)</span> is the value Bob received for the <span class="math inline">\(i\)</span>th character.</p>
<p>The first equation will be <span class="math inline">\(a_3 + a_2 + a_1 + a_0 = 2(1 + b_0)\)</span>, which simplifies to <span class="math inline">\(a_3 + a_2 + a_1 + a_0 + 5b_0 = 2\)</span>. Bob can determine the remaining equations in the same manner, obtaining:</p>
<p>Then clearly <span class="math display">\[P(x)E(x) = R(x)E(x)\]</span> for <span class="math inline">\(x = 1, 2, \ldots, 5\)</span> (if the corruption occurred at position <span class="math inline">\(i\)</span>, then <span class="math inline">\(E(i) = 0\)</span>, so equality trivially holds, and otherwise <span class="math inline">\(P(i) = R(i) = c&#39;_i\)</span>). Bob doesn’t know what <span class="math inline">\(P\)</span> is (though he does know it is a degree <span class="math inline">\(2\)</span> polynomial) and he doesn’t know what <span class="math inline">\(E\)</span> is either, but using the relationship above he can obtain a linear system whose solutions will be the coefficients of <span class="math inline">\(P\)</span> and <span class="math inline">\(E\)</span>, as seen below.</p>
<p>Let <span class="math display">\[Q(x) = a_3x^3 + a_2x^2 + a_1x + a_0 = P(x)E(x),\]</span> where <span class="math inline">\(a_3, a_2, a_1, a_0\)</span> are unknown coefficients (which Bob will soon try to determine), so <span class="math display">\[a_3x^3 + a_2x^2 + a_1x + a_0 = R(x)E(x) = R(x)(x - e_1),\]</span> which he can rewrite as <span class="math display">\[a_3x^3 + a_2x^2 + a_1x + a_0 + R(x)e_1 = R(x)x.\]</span></p>
<p><span class="math display">\[\begin{aligned}
a_3 + a_2 + a_1 + a_0 + 5b_0 &amp;= 2 \\
a_3 + 4a_2 + 2a_1 + a_0 &amp;= 0 \\
6a_3 + 2a_2 + 3a_1 + a_0 + b_0 &amp;= 4 \\
a_3 + 2a_2 + 4a_1 + a_0 &amp;= 0 \\
6a_3 + 4a_2 + 5a_1 + a_0 + 4b_0 &amp;= 1\end{aligned}\]</span></p>
<p>Bob then solves this linear system and finds that <span class="math inline">\(a_3 = 1,\)</span> <span class="math inline">\(a_2 = 0,\)</span> <span class="math inline">\(a_1 = 0,\)</span> <span class="math inline">\(a_0 = 6,\)</span> and <span class="math inline">\(b_0 = 6\)</span> (all mod <span class="math inline">\(7\)</span>). (As a check, this implies that <span class="math inline">\(E(x)=x+6=x-1\)</span>, so the location of the error is position <span class="math inline">\(e_1=1\)</span>, which is correct since the first character was corrupted from a “d” to a “c”.) This gives him the polynomials <span class="math inline">\(Q(x) = x^3 + 6\)</span> and <span class="math inline">\(E(x) = x - 1\)</span>. He can then find <span class="math inline">\(P(x)\)</span> by computing the quotient <span class="math display">\[P(x) = \frac{Q(x)}{E(x)} = \frac{x^3 + 6}{x - 1} = x^2 + x + 1.\]</span> Bob notices that the first character was corrupted (since <span class="math inline">\(e_1 = 1\)</span>), so now that he has <span class="math inline">\(P(x)\)</span>, he just computes <span class="math inline">\(P(1) = 3 =\)</span> “d” and obtains the original, uncorrupted message “dag”.</p>
<p>It is very informative to try doing this example yourself with some modifications. What happens if instead of changing the first character, we changed the second character? Do this and notice that everything still works.</p>
<p>What happens if we don’t change any character at all? In other words, we think that there might be a single error, but there isn’t any error. This is something worth doing on your own ahead of lecture, and then look at the footnote here<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> for commentary. What happens if you change two characters instead of just one?</p>
<h3 id="finer-points-regarding-berlekamp-welch" class="unnumbered">Finer Points Regarding Berlekamp-Welch</h3>
<p>Two points need further discussion. How do we know that the <span class="math inline">\(n + 2k\)</span> equations are consistent? What if they have no solution? This is simple. The equations must be consistent since <span class="math inline">\(Q(x) = P(x)E(x)\)</span> together with the true error locator polynomial <span class="math inline">\(E(x)\)</span> gives a solution, as long as there are exactly <span class="math inline">\(k\)</span> errors.</p>
<p>Now, from the perspective of what we know about systems of linear equations, we have only ruled out the possibility of there being no solution. With <span class="math inline">\(n+2k\)</span> equations and <span class="math inline">\(n+2k\)</span> unknowns, the possibilities are that we have exactly <span class="math inline">\(1\)</span> solution or many solutions.</p>
<p>So, the core interesting question is this: how do we know that the <span class="math inline">\(n + 2k\)</span> equations are independent, i.e., how do we know that there aren’t many other spurious solutions in addition to the correct solution that we are looking for? Put more mathematically, how do we know that a solution <span class="math inline">\(Q&#39;(x)\)</span> and <span class="math inline">\(E&#39;(x)\)</span> that we reconstruct satisfies the property that <span class="math inline">\(E&#39;(x)\)</span> divides <span class="math inline">\(Q&#39;(x)\)</span> and that <span class="math display">\[\frac{Q&#39;(x)}{E&#39;(x)} =
\frac{Q(x)}{E(x)}= P(x)?\]</span></p>
<p>How to check that a ratio is the same? Use “cross products” from elementary school!</p>
<p>We claim that <span class="math inline">\(Q(x)E&#39;(x) = Q&#39;(x)E(x)\)</span> for <span class="math inline">\(1\leq x\leq n + 2k\)</span>. This is a statement about evaluations of these polynomials. Since the degree of both <span class="math inline">\(Q(x)E&#39;(x)\)</span> and <span class="math inline">\(Q&#39;(x)E(x)\)</span> is <span class="math inline">\(n + 2k - 1\)</span> and they are equal at <span class="math inline">\(n + 2k\)</span> points, it follows from <a href="n8.html#prop:prop2">Property 2</a> that they are the same polynomial. Once we know that they are the same polynomial, we can divide both sides by the polynomial <span class="math inline">\(E(x)E&#39;(x)\)</span> since that polynomial is by construction not the zero polynomial. Rearranging, we get <span class="math display">\[\frac{Q&#39;(x)}{E&#39;(x)} =
\frac{Q(x)}{E(x)}= P(x).\]</span></p>
<p>So, it all hinges on the claim that <span class="math inline">\(Q(x)E&#39;(x) = Q&#39;(x)E(x)\)</span> for all <span class="math inline">\(1\leq x\leq n + 2k\)</span>. Why is this claim true for these values? Based on our method of obtaining <span class="math inline">\(Q&#39;(x)\)</span> and <span class="math inline">\(E&#39;(x)\)</span>, we know that <span class="math inline">\(Q&#39;(i) = r_iE&#39;(i)\)</span> and <span class="math inline">\(Q(i) = r_iE(i)\)</span>. Now assume <span class="math inline">\(E(i)\)</span> is <span class="math inline">\(0\)</span>. Then <span class="math inline">\(Q(i)\)</span> is also <span class="math inline">\(0\)</span>, so both <span class="math inline">\(Q(i)E&#39;(i)\)</span> and <span class="math inline">\(Q&#39;(i)E(i)\)</span> are <span class="math inline">\(0\)</span> and the claim holds. The same reasoning applies when <span class="math inline">\(E&#39;(i)\)</span> is <span class="math inline">\(0\)</span>.</p>
<p>That leaves the case when both <span class="math inline">\(E(i)\)</span> and <span class="math inline">\(E&#39;(i)\)</span> are not <span class="math inline">\(0\)</span>. In this case, we are free to divide by it. So, we get <span class="math display">\[\frac{Q&#39;(i)}{E&#39;(i)} =
r_i\]</span> and also <span class="math display">\[\frac{Q(i)}{E(i)} = r_i.\]</span> Since they are both equal to <span class="math inline">\(r_i\)</span>, they are equal to each other. So we get <span class="math display">\[\frac{Q&#39;(i)}{E&#39;(i)} =
\frac{Q(i)}{E(i)}.\]</span> Doing cross-products (multiplying both sides of the equation by <span class="math inline">\(E(i)E&#39;(i)\)</span> and simplifying) now gives us the claim. Since the claim is now proven for all cases, it holds for all <span class="math inline">\(1 \leq x \leq n+2k\)</span>.</p>
<p>This means that when there are multiple solutions, they all point to the same polynomial, and hence to the same message. As you saw from playing around with the example, this actually happens when there are fewer errors than budgeted for.</p>
<h2 id="distance-properties" class="unnumbered">Distance Properties</h2>
<p>So far, we have talked about the Reed-Solomon codes in a way that constantly references their polynomial-evaluation based nature. However, it is useful to step back and ask ourselves what generic features of the codewords enabled us to recover from erasures and general errors.</p>
<p>It is useful here to treat a codeword as a string/vector of some fixed length, say <span class="math inline">\(L\)</span> characters long. To protect a message of length <span class="math inline">\(n\)</span> against <span class="math inline">\(k\)</span> erasures, we saw that <span class="math inline">\(L \geq n+k\)</span> was required. To protect a message of length <span class="math inline">\(n\)</span> against <span class="math inline">\(k\)</span> general errors introduced by a malicious adversary, we saw that <span class="math inline">\(L \geq n+2k\)</span> was required. It is a natural question to wonder whether this is merely a feature of the Reed-Solomon codes or whether it is more fundamental.</p>
<p>To answer this, we define a kind of “distance” on strings of length <span class="math inline">\(L\)</span>. We say that the <span><em>Hamming distance</em></span> between strings <span class="math inline">\(\vec{s} = (s_1, s_2, \ldots, s_L)\)</span> and <span class="math inline">\(\vec{r} = (r_1, r_2, \ldots, r_L)\)</span> is just the count of the number of positions in which the two strings differ. In mathematical notation: <span class="math display">\[\begin{aligned}
d(\vec{s},\vec{r}) = \sum_{i=1}^L {\mathbf 1}(r_i \neq s_i)\end{aligned}\]</span> where the notation <span class="math inline">\({\mathbf 1}(r_i \neq s_i)\)</span> denotes a function that returns a <span class="math inline">\(1\)</span> if the condition inside is true and <span class="math inline">\(0\)</span> if it is false.</p>
<p>The error and erasure correcting properties of a code are determined by the distance properties of the codewords <span class="math inline">\(\vec{c}(m)\)</span>, Intuitively, if the codewords are too close together, then the code is more sensitive to errors and erasures. Having codewords far apart from each other allows a code, in principle, to tolerate more erasures and errors.</p>
<p>To make this precise, the <span><em>Minimum Distance</em></span> of a code is defined as the distance between the two closest codewords. Let <span class="math inline">\(m\)</span> and <span class="math inline">\(\widetilde{m}\)</span> be two distinct messages <span class="math inline">\(m \neq \widetilde{m}\)</span>. Then the minimum distance of the code is <span class="math inline">\(\min_{m \neq \widetilde{m}} d(\vec{c}(m),\vec{c}(\widetilde{m}))\)</span>.</p>
<p>If the messages themselves are the set of strings of length <span class="math inline">\(n\)</span>, then the minimum distance of the set of messages is just <span class="math inline">\(1\)</span> because two distinct strings must differ somewhere. So clearly, when the minimum distance is <span class="math inline">\(1\)</span>, there is no protection against errors or erasures.</p>
<p>When the minimum distance is larger than <span class="math inline">\(1\)</span>, then there is some protection against erasures and errors. Suppose that the minimum distance was <span class="math inline">\(2\)</span> and one position was erased in a codeword. In principle, cycling through all the possible characters for that position would certainly yield at least <span class="math inline">\(1\)</span> codeword because the true codeword could be obtained that way. But notice that no other codeword could be obtained that way since if one were to be obtained, it would have a Hamming distance of just <span class="math inline">\(1\)</span> — and we stipulated that the minimum distance was <span class="math inline">\(2\)</span>.</p>
<p>It is a simple exercise to generalize the above argument to show that when the minimum distance is <span class="math inline">\(k+1\)</span> or better, then the code can in principle recover from <span class="math inline">\(k\)</span> erasure errors. If the minimum distance is <span class="math inline">\(k\)</span> or less, then there is clearly a codeword pair for which erasing <span class="math inline">\(k\)</span> positions would make the pair ambiguous. The resulting string could have come from either of these codewords. So we can’t hope for anything better.</p>
<p>For general errors, the situation is a little trickier. To get an intuition for what the corresponding story should be, imagine that you are an attacker and want to confuse the decoder. You see the encoded codeword. What are you going to do? It is intuitively clear that you will want to make the received string look like it came from another codeword. What codeword would you choose to impersonate? Intuitively, it makes sense to look for the closest codeword in the neighborhood. Suppose it was at a Hamming distance of <span class="math inline">\(d\)</span>. That means that if you were to change <span class="math inline">\(d\)</span> positions, then you could make the received string look exactly like this other codeword. Clearly, the decoder is pretty much guaranteed to make an error at this point.</p>
<p>But what if you only changed <span class="math inline">\(d-1\)</span> positions to partially impersonate the other codeword? At this point, the decoder is facing a choice. It could decode to this other codeword and chalk the single-position discrepancy up to general errors, or it could decode to the true codeword and think that <span class="math inline">\(d-1\)</span> positions have been changed. What choice will it make? In general, the decoder will be perfectly confused between these two choices if exactly <span class="math inline">\(d/2\)</span> errors have been made in a malicious way designed to partially impersonate this other codeword. However, if the number of general errors are strictly less than half the minimum distance of the code, in principle we should be able to decode the unique codeword that is less than <span class="math inline">\(d/2\)</span> from the received string.</p>
<h3 id="the-distance-properties-of-reed-solomon-codes" class="unnumbered">The Distance Properties of Reed-Solomon Codes</h3>
<p>It turns out that Reed-Solomon codes have the best-possible distance properties. (Of course, that is only a part of their attraction. Their other attraction is that their algebraic structure gives us a very nice efficient way of decoding these codes by solving systems of linear equations instead of brute-force searching through all nearby codewords.)</p>
<p><span id="thm:t1" class="pandoc-numbering-text thm"><strong>Theorem 1</strong></span></p>
<p><em>The Reed Solomon code that takes <span class="math inline">\(n\)</span> message characters to a codeword of size <span class="math inline">\(n+2k\)</span> has minimum distance <span class="math inline">\(2k+1\)</span>.</em></p>
<p><em>Proof</em>. We prove this using the two claims:</p>
<p><span id="claim:c1" class="pandoc-numbering-text claim"><strong>Claim 1</strong></span></p>
<p><em>The minimum distance is <span class="math inline">\(\leq 2k + 1\)</span>.</em></p>
<p><span id="claim:c2" class="pandoc-numbering-text claim"><strong>Claim 2</strong></span></p>
<p><em>The minimum distance is <span class="math inline">\(\geq 2k+1\)</span>.</em></p>
<p>If we show that both <a href="#claim:c1">Claim 1</a> and <a href="#claim:c2">Claim 2</a> are true, then the minimum distance must be <span class="math inline">\(2k+1\)</span>. <span class="math inline">\(\square\)</span></p>
<p><em>Proof of <a href="#claim:c1">Claim 1</a></em>.</p>
<p>We prove <a href="#claim:c1">Claim 1</a> by constructing an example. If we can show there exist two codewords <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span> such that <span class="math inline">\(d(\vec{c}_a, \vec{c}_b) \leq 2k+1\)</span>, then the minimum over all distances between codewords must be <span class="math inline">\(\leq 2k+1\)</span>.</p>
<p>Consider <span class="math inline">\(\vec{m}_a = m_1 m_2 \cdots m_n\)</span>. Also consider <span class="math inline">\(\vec{m}_b = m_1 m_2 \cdots \bar{m}_n\)</span>, where the two messages are identical in the first <span class="math inline">\(n-1\)</span> positions but differ in the last position. (All strings of length <span class="math inline">\(n\)</span> are valid messages.) So <span class="math inline">\(m_n \neq \bar{m}_n\)</span>. The Hamming distance between these two messages is <span class="math inline">\(1\)</span>. We use these messages to generate polynomials <span class="math inline">\(P_a(x)\)</span> and <span class="math inline">\(P_b(x)\)</span> and these are evaluated at <span class="math inline">\(i\)</span> such that <span class="math inline">\(1 \leq i \leq n+2k\)</span> to generate the codewords <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span> of length <span class="math inline">\(n+2k\)</span>. We use value/interpolation encoding, so <span class="math inline">\(P_a(i) = m_i = P_b(i)\)</span> for <span class="math inline">\(1\leq i \leq n-1\)</span>. So the first <span class="math inline">\(n-1\)</span> positions of <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span> are identical. So they can differ in at most <span class="math inline">\(n+2k - (n-1) = 2k+1\)</span> places. But this means the Hamming distance between them is <span class="math inline">\(\leq 2k+1\)</span>. So we have constructed two codewords that have distance at most <span class="math inline">\(2k+1\)</span>. Then the minimum distance between all pairs of codewords must be less than or equal to this. Hence, the minimum distance <span class="math inline">\(\leq 2k+1\)</span>. <span class="math inline">\(\square\)</span></p>
<p><em>Proof of <a href="#claim:c2">Claim 2</a></em>.</p>
<p>Assume it were possible that the minimum distance between two distinct codewords could be <span class="math inline">\(\leq 2k\)</span>. We use this to reach a contradiction. Let these two distinct codewords be <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span>, corresponding to distinct message polynomials <span class="math inline">\(P_a(x)\)</span> and <span class="math inline">\(P_b(x)\)</span>. (Note: these have nothing to do with the <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span> used in the Proof for <a href="#claim:c1">Claim 1</a>, we are just using the same variable names.) By the construction of Reed-Solomon codes, <span class="math inline">\(P_a(x)\)</span> and <span class="math inline">\(P_b(x)\)</span> have degree <span class="math inline">\(n-1\)</span> since the message is of size <span class="math inline">\(n\)</span>.</p>
<p>Then, <span class="math inline">\(d(\vec{c}_a, \vec{c}_b) \leq 2k\)</span>. So <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span> must be identical in <span class="math inline">\(\geq n+2k - 2k = n\)</span> positions. But <span class="math inline">\(\vec{c}_a\)</span> and <span class="math inline">\(\vec{c}_b\)</span> are just the evaluations of the message polynomials <span class="math inline">\(P_a(x)\)</span> and <span class="math inline">\(P_b(x)\)</span> at <span class="math inline">\(1 \leq i \leq n+2k\)</span>. So <span class="math inline">\(P_a(x)\)</span> and <span class="math inline">\(P_b(x)\)</span> are identical on at least <span class="math inline">\(n\)</span> points. But this means they must be the same polynomial, since they are of degree <span class="math inline">\(n-1\)</span>, which is a contradiction, since we assumed that <span class="math inline">\(\vec{c}_a \neq \vec{c}_b\)</span> were distinct codewords. So our assumptions must be false, and the minimum distance between two distinct codewords is <span class="math inline">\(\geq 2k+1\)</span>. <span class="math inline">\(\square\)</span></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is also reflected in an interesting history. The IEEE was formed by the merger of two societies — the Institute of Radio Engineers and the American Institute of Electrical Engineers. The Radio Engineers were intimately involved with communication, cryptography, radar, etc. The IRE and AIEE merged to form the IEEE in 1963, but the IRE was already bigger than the AIEE by 1957. This merger was natural because electronics was becoming an important implementation substrate for both sets of engineers and the modern theory of electrical systems used the same mathematics as radio and signal processing (as well as control). This is why the word “EE” is often used to describe these computer sciences. At Berkeley, of course, this is all just a historical footnote since you simply experience EECS as a single entity, but the history remains in some of the course numbers.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Like RSA, these carry the names of their inventors Reed and Solomon. The modern use of these codes is largely related to what are called BCH codes, named after Bose, Chaudhuri, and Hocquenghem. We cannot get into these differences but the Wikipedia articles here are pretty decent.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Where do packets come from? They are little pieces of information obtained by chopping up whatever actual message that we have.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>In real-world implementations, we do not do this. Instead, we work directly in finite fields that have size <span class="math inline">\(2^{32}\)</span> because that is a prime power and working with fields that are a power-of-two in size is convenient for computer operations. However, the construction of such fields is beyond the scope of 70.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>It is an exercise because it involves thinking about linear algebra, and generalizing the ideas to finite fields. The key idea here is that the monomials <span class="math inline">\(x^k\)</span> are linearly independent of each other as long as there aren’t too many of them relative to the size of the finite field. This fact follows from the properties of polynomials already established. (Finding a non-zero linear combination of monomials that equals zero everywhere is basically asking for a polynomial to have a lot of roots.)<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Can you prove this? You should be able to. Assume that there are no more than <span class="math inline">\(k\)</span> errors. Now suppose there were a second polynomial of degree <span class="math inline">\(n-1\)</span> that agreed with the received symbols in <span class="math inline">\(n+k\)</span> positions. This means that it must also agree with the true <span class="math inline">\(P(x)\)</span> in <span class="math inline">\(n\)</span> positions since there cannot be more than <span class="math inline">\(k\)</span> errors. But then, <a href="n8.html#prop:prop2">Property 2</a> of polynomials tells us that this second polynomial must in fact be equal to the original polynomial since <span class="math inline">\(n\)</span> points uniquely specify a polynomial of degree at most <span class="math inline">\(n-1\)</span>.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>You will notice that in this case, the system of linear equations will become degenerate and will have multiple solutions. But this is exactly what should happen. Why? You can place the error wherever you want and the system of equations will still be consistent — the adversary has just replaced a value with itself! As a matter of calculation, you can simply choose any solution and proceed to successful decoding.<a href="#fnref7">↩</a></p></li>
</ol>
</div>
</article>
</body>

<!-- Mirrored from www.eecs70.org/static/notes/n9.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 May 2018 00:39:44 GMT -->
</html>
