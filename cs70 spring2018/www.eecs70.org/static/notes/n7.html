<!DOCTYPE html>
<!--==============================================================================
	           "GitHub HTML5 Pandoc Template" v1.2 — by Tristano Ajmone           
	==============================================================================
	(c) Tristano Ajmone, 2017, MIT License (MIT). Project's home repository:

	- https://github.com/tajmone/pandoc-goodies

	This template reuses source code taken from the following projects:

	- GitHub Markdown CSS: © Sindre Sorhus, MIT License (MIT):
	  https://github.com/sindresorhus/github-markdown-css

	- Primer CSS: © 2016 GitHub Inc., MIT License (MIT):
	  http://primercss.io/
	==============================================================================-->
<html>

<!-- Mirrored from www.eecs70.org/static/notes/n7.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 May 2018 00:39:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Public Key Cryptography</title>
<style type="text/css">@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,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) format('woff')}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5;word-wrap:break-word;box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects;color:#0366d6;text-decoration:none}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body h1{margin:.67em 0}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #dfe2e5}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:100%;overflow:auto}.markdown-body td,.markdown-body th{padding:0}.markdown-body blockquote{margin:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.markdown-body pre{font:12px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;word-wrap:normal}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{font-size:11px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#6a737d}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:"\00a0"}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fcfcfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.flash{position:relative;padding:16px;color:#246;background-color:#e2eef9;border:1px solid #bac6d3;border-radius:3px}.flash p:last-child{margin-bottom:0}.flash-messages{margin-bottom:24px}.flash-warn{color:#4c4a42;background-color:#fff9ea;border-color:#dfd8c2}.flash-error{color:#911;background-color:#fcdede;border-color:#d2b2b2}.flash-success{color:#22662c;background-color:#e2f9e5;border-color:#bad3be}.flash-plain{color:#4c4a42;background-color:#f5f5f5;border-color:#c1c1c1}.figure{text-align:center;}</style>
  <style type="text/css">code{white-space: pre;}</style>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {equationNumbers: {autoNumber: "AMS"}}
    });
  </script>
  <script src="../../../cdn.mathjax.org/mathjax/latest/MathJax2ba6.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<article class="markdown-body">
<header>
<h1 class="title">Public Key Cryptography</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#public-key-cryptography">Public Key Cryptography</a><ul>
<li><a href="#bijections">Bijections</a></li>
<li><a href="#rsa">RSA</a></li>
</ul></li>
</ul>
</nav>
<p><span><em>This note is partly based on Section 1.4 of “Algorithms,&quot; by S. Dasgupta, C. Papadimitriou, and U. Vazirani, McGraw-Hill, 2007.</em></span></p>
<h1 id="public-key-cryptography" class="unnumbered">Public Key Cryptography</h1>
<p>In this note, we discuss a very nice and important application of modular arithmetic: the <span><em>RSA public-key cryptosystem</em></span>, named after its inventors Ronald Rivest, Adi Shamir, and Leonard Adleman.</p>
<p>Cryptography is an ancient subject that really blossomed into its modern form at the same time<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> as the other great revolutions in the general fields of information science/engineering. The setting for basic cryptography is typically described via a cast of three characters: Alice and Bob, who with to communicate confidentially over some (insecure) link, and Eve, an eavesdropper who is listening in and trying to discover what they are saying.</p>
<p>Let’s assume that Alice wants to transmit a message <span class="math inline">\(x\)</span> (written in binary) to Bob. She will apply her <span><em>encryption function</em></span> <span class="math inline">\(E\)</span> to <span class="math inline">\(x\)</span> and send the encrypted message <span class="math inline">\(E(x)\)</span> (also called the <span><em>cyphertext</em></span>) over the link; Bob, upon receipt of <span class="math inline">\(E(x)\)</span>, will then apply his <span><em>decryption function</em></span> <span class="math inline">\(D\)</span> to it and thus recover the original message (also called the <span><em>plaintext</em></span>): i.e., <span class="math inline">\(D(E(x)) = x\)</span>.</p>
<p>Since the link is insecure, Alice and Bob have to assume that Eve may get hold of <span class="math inline">\(E(x)\)</span>. (Think of Eve as being a “sniffer&quot; on the network.) Thus ideally we would like to know that the encryption function <span class="math inline">\(E\)</span> is chosen so that just knowing <span class="math inline">\(E(x)\)</span> (without knowing the decryption function <span class="math inline">\(D\)</span>) doesn’t allow one to discover anything about the original message <span class="math inline">\(x\)</span>.</p>
<p>For millenia cryptography was based on what are now called <span><em>private-key</em></span> protocols. In such a scheme, Alice and Bob meet beforehand and together choose a secret codebook, with which they encrypt all future correspondence between them. (This codebook plays the role of the functions <span class="math inline">\(E\)</span> and <span class="math inline">\(D\)</span> above.) Eve’s only hope then is to collect some encrypted messages and use them to at least partially figure out the codebook.</p>
<p><span><em>Public-key</em></span> schemes, such as RSA, are significantly more subtle and tricky: they allow Alice to send Bob a secure message without ever having met him privately before! This almost sounds impossible, because in this scenario there is a symmetry between Bob and Eve: why should Bob have any advantage over Eve in terms of being able to understand Alice’s message? The central idea between the RSA cryptosystem is that Bob is able to implement a <span><em>digital lock</em></span>, to which only he has the key. Now by making this digital lock public, he gives Alice (or, indeed, anybody else) a way to send him a secure message which only he can open.</p>
<p>Here is how the digital lock is implemented in the RSA scheme. Each person has a <span><em>public key</em></span> known to the whole world, and a <span><em>private key</em></span> known only to themselves. When Alice wants to send a message <span class="math inline">\(x\)</span> to Bob, she encodes it using Bob’s public key. Bob then decrypts it using his private key, thus retrieving <span class="math inline">\(x\)</span>. Eve is welcome to see as many encrypted messages for Bob as she likes, but she will not be able to decode them (under certain simple assumptions explained below).</p>
<p>But before we can go into how to use modulo arithmetic to achieve this sort of scheme, we need to review some basic properties of functions.</p>
<h2 id="bijections" class="unnumbered">Bijections</h2>
<p>A function is a mapping from a set (called the <span><em>domain</em></span>) of inputs <span class="math inline">\(A\)</span> to a set of outputs <span class="math inline">\(B\)</span>: for input <span class="math inline">\(x\in A\)</span>, <span class="math inline">\(f(x)\)</span> must be in the set <span class="math inline">\(B\)</span>. To denote such a function, we write <span class="math inline">\(f: A\rightarrow B\)</span>. The set <span class="math inline">\(B\)</span> is known as the <em>codomain</em> of <span class="math inline">\(f\)</span>, but it is important to recognize that <span class="math inline">\(f\)</span> may not output every element in <span class="math inline">\(B\)</span>. For example, we write <span class="math inline">\(f : {\mathbb{R}}\to {\mathbb{R}}\)</span> for the function <span class="math inline">\(f(x) := x^2\)</span>, but the function <span class="math inline">\(f\)</span> only ever outputs non-negative numbers. To distinguish between the set <span class="math inline">\(B\)</span> and the actual possible outputs of <span class="math inline">\(f\)</span>, we define the set <span class="math inline">\(f(A) := \{f(a) : a \in A\}\)</span> to be the <em>range</em> (or <em>image</em>) of <span class="math inline">\(f\)</span>. In the example of <span class="math inline">\(f(x) = x^2\)</span>, the range is the set of non-negative real numbers.</p>
<p>Consider the following examples of functions, where both functions map <span class="math inline">\(\{0,\dots,m-1\}\)</span> to itself: <span class="math display">\[f(x) = x + 1 \bmod m\]</span> <span class="math display">\[g(x) = 2x \bmod m\]</span></p>
<p>A bijection is a function for which every <span class="math inline">\(b\in B\)</span> has a unique <span><em>pre-image</em></span> <span class="math inline">\(a\in A\)</span> such that <span class="math inline">\(f(a) = b\)</span>. Note that this consists of two conditions:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(f\)</span> is <span><em>onto</em></span>: every <span class="math inline">\(b \in B\)</span> has a pre-image <span class="math inline">\(a\in A\)</span>.</p></li>
<li><p><span class="math inline">\(f\)</span> is <span><em>one-to-one</em></span>: for all <span class="math inline">\(a,a&#39;\in A\)</span>, if <span class="math inline">\(f(a) = f(a&#39;)\)</span> then <span class="math inline">\(a = a&#39;\)</span>.</p></li>
</ol>
<p>Looking back at our examples, we can see that <span class="math inline">\(f\)</span> is a bijection; the unique pre-image of <span class="math inline">\(y\)</span> is <span class="math inline">\(y - 1\)</span>. However, <span class="math inline">\(g\)</span> is only a bijection if <span class="math inline">\(m\)</span> is odd. Otherwise, it is neither one-to-one nor onto. The following lemma can be used to prove that a function is a bijection:</p>
<p><span id="lem:bijection" class="pandoc-numbering-text lem"><strong>Lemma 1</strong></span></p>
<p><em>For a finite set <span class="math inline">\(A\)</span>, <span class="math inline">\(f: A\rightarrow A\)</span> is a bijection if there is an <span><em>inverse</em></span> function <span class="math inline">\(g: A\rightarrow A\)</span> such that <span class="math inline">\(\forall x\in A\)</span> <span class="math inline">\(g(f(x)) = x\)</span>.</em></p>
<p><em>Proof</em>. If <span class="math inline">\(f(x) = f(x&#39;)\)</span>, then <span class="math inline">\(x = g(f(x)) = g(f(x&#39;)) = x&#39;\)</span>. Therefore, <span class="math inline">\(f\)</span> is one-to-one. Since <span class="math inline">\(f\)</span> is one-to-one, there must be <span class="math inline">\(|A|\)</span> elements in the range of <span class="math inline">\(f\)</span>. This implies that <span class="math inline">\(f\)</span> is also onto. <span class="math inline">\(\square\)</span></p>
<p>Moreover, in the case that <span class="math inline">\(f\)</span> maps a finite set to itself, if <span class="math inline">\(f\)</span> to be one-to-one then it is necessarily onto:</p>
<p><span id="lem:finite" class="pandoc-numbering-text lem"><strong>Lemma 2</strong></span></p>
<p><em>If <span class="math inline">\(f:A \rightarrow A\)</span> is one-to-one and <span class="math inline">\(A\)</span> is a finite set, then <span class="math inline">\(f\)</span> is a bijection.</em></p>
<p><em>Proof</em>. Let <span class="math inline">\(|A| = n\)</span>. Since <span class="math inline">\(f\)</span> is one-to-one, there must be <span class="math inline">\(n\)</span> elements in the image of <span class="math inline">\(f\)</span>. But that means that every element in <span class="math inline">\(A\)</span> must be hit. <span class="math inline">\(\square\)</span></p>
<h2 id="rsa" class="unnumbered">RSA</h2>
<p>A particularly practical family of bijections is the RSA function, named after its inventors Ronald Rivest, Adi Shamir, and Leonard Adleman:</p>
<p><span class="math display">\[E(x) = x^e \bmod N\]</span></p>
<p>where <span class="math inline">\(N= pq\)</span> (<span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are two large primes), <span class="math inline">\(E: \{0,\dots,N-1\}\rightarrow\{0,\dots,N-1\}\)</span> and <span class="math inline">\(e\)</span> is relatively prime to <span class="math inline">\((p-1)(q-1)\)</span>. The inverse of the RSA function is:</p>
<p><span class="math display">\[D(x) = x^d \bmod N\]</span></p>
<p>where <span class="math inline">\(d\)</span> is the inverse of <span class="math inline">\(e \mod (p-1)(q-1)\)</span>. In other words <span class="math inline">\(ed \equiv 1 \pmod{(p-1)(q-1)}\)</span>.</p>
<p>Let’s bring back our standard cast of characters and assume that Alice wants to transmit a message <span class="math inline">\(x\)</span> (mapped into a number between <span class="math inline">\(2\)</span> and <span class="math inline">\(N - 1\)</span>. Can you see why we avoid both <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>?) to Bob. In order to encrypt the message, Alice only needs Bob’s <span><em>public key</em></span> <span class="math inline">\((N,e)\)</span>. In order to decrypt the message, Bob needs his <span><em>private key</em></span> <span class="math inline">\(d\)</span>. The pair <span class="math inline">\((N,e)\)</span> can be thought of as the serial number of the public lock - anyone can place a message in a box and lock it, but only Bob has the key <span class="math inline">\(d\)</span> to open the lock. The idea is that since Eve does not have access to <span class="math inline">\(d\)</span>, she will not be able to gain information about Alice’s message.</p>
<p>Here is an example:</p>
<p><span><strong>Example:</strong></span> Let <span class="math inline">\(p=5\)</span>, <span class="math inline">\(q=11\)</span>, and <span class="math inline">\(N=pq=55\)</span>. (In practice, <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> would be much larger.) Then we can choose <span class="math inline">\(e=3\)</span>, which is relatively prime to <span class="math inline">\((p-1)(q-1)=40\)</span>. Thus Bob’s public key is <span class="math inline">\((55,3)\)</span>. His private key is <span class="math inline">\(d=3^{-1}\pmod{40} = 27\)</span>. For any message <span class="math inline">\(x\)</span> that Alice (or anybody else) wishes to send to Bob, the encryption of <span class="math inline">\(x\)</span> is <span class="math inline">\(y = x^3\bmod 55\)</span>, and the decryption of <span class="math inline">\(y\)</span> is <span class="math inline">\(x=y^{27}\bmod 55\)</span>. So, for example, if the message is <span class="math inline">\(x=13\)</span>, then the encryption is <span class="math inline">\(y=13^3=52\bmod 55\)</span>, and this is decrypted as <span class="math inline">\(13=52^{27}\bmod 55\)</span>.</p>
<p>We will now prove that <span class="math inline">\(D(E(x)) = x\)</span> (and therefore <span class="math inline">\(E(x)\)</span> is a bijection). We will require a beautiful theorem from number theory known as <span><em>Fermat’s Little Theorem</em></span>, which is the following:</p>
<p><span id="thm:fermat" class="pandoc-numbering-text thm"><strong>Theorem 1</strong> <em>(Fermat's Little Theorem)</em></span></p>
<p><em>For any prime <span class="math inline">\(p\)</span> and any <span class="math inline">\(a\in\{1,2,\ldots,p-1\}\)</span>, we have <span class="math inline">\(a^{p-1} \equiv 1 \pmod{p}\)</span>.</em></p>
<p>Let <span class="math inline">\(S\)</span> be the nonzero integers modulo <span class="math inline">\(p\)</span>; that is, <span class="math inline">\(S = \{1,2,\ldots, p-1\}\)</span>. Define a function <span class="math inline">\(f: S\rightarrow S\)</span> such that <span class="math inline">\(f(x) = ax\bmod p\)</span>. Here’s the crucial observation: <span class="math inline">\(f\)</span> is simply a bijection from <span class="math inline">\(S\)</span> to <span class="math inline">\(S\)</span>; it permutes the elements of <span class="math inline">\(S\)</span>. For instance, here’s a picture of the case <span class="math inline">\(a = 3, p = 7\)</span>:</p>
<div class="figure">
<img src="n7-bij.png" alt="Figure 1: Multiplication by 3, mod 7." id="fig:bij" style="width:20.0%" />
<p class="caption">Figure 1: Multiplication by <span class="math inline">\(3\)</span>, mod <span class="math inline">\(7\)</span>.</p>
</div>
<p>With this intuition, we can now prove Fermat’s Little Theorem:</p>
<p><em>Proof of <a href="#thm:fermat">Theorem 1</a></em>. Our first claim is that <span class="math inline">\(f(x)\)</span> is a bijection. We will then show that this claim implies the theorem.</p>
<p>To show that <span class="math inline">\(f\)</span> is a bijection, we simply need to argue that the numbers <span class="math inline">\(a\cdot i\bmod p\)</span> are distinct. This is because if <span class="math inline">\(a \cdot i \equiv a \cdot j \pmod p\)</span>, then dividing both sides by <span class="math inline">\(a\)</span> gives <span class="math inline">\(i \equiv j \pmod p\)</span>. They are nonzero because <span class="math inline">\(a \cdot i \equiv 0\)</span> similarly implies <span class="math inline">\(i \equiv 0\)</span>. (And we <span><em>can</em></span> divide by <span class="math inline">\(a\)</span>, because by assumption it is nonzero and therefore relatively prime to <span class="math inline">\(p\)</span>. So a multiplicative inverse for <span class="math inline">\(a\)</span> must exist.)</p>
<p>Now we can prove the theorem. Since <span class="math inline">\(f\)</span> is a bijection, we know that the image of <span class="math inline">\(f\)</span> is <span class="math inline">\(S\)</span>. Now if we take the product of all elements in <span class="math inline">\(S\)</span>, it is equal to the product of all elements in the image of <span class="math inline">\(f\)</span>. We are essentially looping through the elements of <span class="math inline">\(S\)</span> in two different ways<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. Once in their natural order, and then again in the permuted ordering defined by <span class="math inline">\(f\)</span>. So <span class="math display">\[(p-1)! \equiv a^{p-1} \cdot (p-1)! \pmod p .\]</span> Dividing both sides by <span class="math inline">\((p-1)!\)</span> (which we can do because it is relatively prime to <span class="math inline">\(p\)</span>, since <span class="math inline">\(p\)</span> is assumed prime) then gives the theorem. <span class="math inline">\(\square\)</span></p>
<p>Let us return to proving that <span class="math inline">\(D(E(x)) = x\)</span>:</p>
<p><span id="thm:thm1" class="pandoc-numbering-text thm"><strong>Theorem 2</strong></span></p>
<p><em>Under the above definitions of the encryption and decryption functions <span class="math inline">\(E\)</span> and <span class="math inline">\(D\)</span>, we have <span class="math inline">\(D(E(x)) = x\bmod N\)</span> for every possible message <span class="math inline">\(x\in\{0,1,\ldots,N-1\}\)</span>.</em></p>
<p>The proof of this theorem relies on Fermat’s Little Theorem:</p>
<p><em>Proof of <a href="#thm:thm1">Theorem 2</a></em>. To prove the statement, we have to show that <a name="eq:1"></a><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[
(x^e)^d = x\bmod N\qquad\text{for every $x\in\{0,1,\ldots,N-1\}$}.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(1)</span></span>  Let’s consider the exponent, which is <span class="math inline">\(ed\)</span>. By definition of <span class="math inline">\(d\)</span>, we know that <span class="math inline">\(ed=1\bmod (p-1)(q-1)\)</span>; hence we can write <span class="math inline">\(ed = 1+k(p-1)(q-1)\)</span> for some integer <span class="math inline">\(k\)</span>, and therefore <a name="eq:2"></a><span style="display: inline-block; position: relative; width: 100%"><span class="math display">\[
  x^{ed} - x = x^{1+k(p-1)(q-1)} - x = x(x^{k(p-1)(q-1)}-1).\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(2)</span></span>  Looking back at Equation <a href="#eq:1">1</a>, our goal is to show that this last expression in Equation <a href="#eq:2">2</a> is equal to <span class="math inline">\(0\)</span> mod <span class="math inline">\(N\)</span> for every <span class="math inline">\(x\)</span>.</p>
<p>Now we claim that the expression <span class="math inline">\(x(x^{k(p-1)(q-1)}-1)\)</span> in Equation <a href="#eq:2">2</a> is divisible by <span class="math inline">\(p\)</span>. To see this, we consider two cases:</p>
<ul>
<li><p><strong>Case 1</strong>. <span><em><span class="math inline">\(x\)</span> is not a multiple of <span class="math inline">\(p\)</span></em></span>. In this case, since <span class="math inline">\(x\ne 0\bmod p\)</span>, we can use Fermat’s Little Theorem to deduce that <span class="math inline">\(x^{p-1}=1\bmod p\)</span>. Then <span class="math inline">\((x^{p-1})^{k(q-1)}\equiv 1^{k(q-1)}\bmod p\)</span> and hence <span class="math inline">\(x^{k(p-1)(q-1)}-1=0\bmod p\)</span>, as required.</p></li>
<li><p><strong>Case 2</strong>. <span><em><span class="math inline">\(x\)</span> is a multiple of <span class="math inline">\(p\)</span></em></span>. In this case the expression in Equation <a href="#eq:2">2</a>, which has <span class="math inline">\(x\)</span> as a factor, is clearly divisible by <span class="math inline">\(p\)</span>.</p></li>
</ul>
<p>By an entirely symmetrical argument, <span class="math inline">\(x(x^{k(p-1)(q-1)}-1)\)</span> is also divisible by <span class="math inline">\(q\)</span>. Therefore, it is divisible by both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, and since <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are primes it must be divisible by their product, <span class="math inline">\(pq=N\)</span>. But this implies that the expression is equal to 0 mod <span class="math inline">\(N\)</span>, which is exactly what we wanted to prove. <span class="math inline">\(\square\)</span></p>
<ul>
<li><p><span><strong>[Encryption]:</strong></span> When Alice wants to send a message <span class="math inline">\(x\)</span> (assumed to be an integer mod <span class="math inline">\(N\)</span>) to Bob, she computes the value <span class="math inline">\(E(x)\)</span>, which is itself an integer mod <span class="math inline">\(N\)</span>, and sends this to Bob.</p></li>
<li><p><span><strong>[Decryption]:</strong></span> Upon receiving the value <span class="math inline">\(y=E(x)\)</span>, Bob computes <span class="math inline">\(D(y)\)</span>, and this is equal to the original message <span class="math inline">\(x\)</span>.</p></li>
</ul>
<p>Let us understand the properties that the encryption and decryption functions <span class="math inline">\(E\)</span> and <span class="math inline">\(D\)</span> must satisfy for these conditions to hold.</p>
<p>So we have seen that the RSA protocol is <span><em>correct</em></span>, in the sense that Alice can encrypt messages in such a way that Bob can reliably decrypt them again. But how do we know that it is <span><em>secure</em></span>, i.e., that Eve cannot get any useful information by observing the encrypted messages? The security of RSA hinges upon the following simple assumption: <span class="math display">\[\text{Given $N$, $e$ and $y=x^e\bmod N$, there is no efficient algorithm for determining $x$.}\]</span> This assumption is quite plausible. How might Eve try to guess <span class="math inline">\(x\)</span>? She could experiment with all possible values of <span class="math inline">\(x\)</span>, each time checking whether <span class="math inline">\(x^e=y\bmod N\)</span>; but she would have to try on the order of <span class="math inline">\(N\)</span> values of <span class="math inline">\(x\)</span>, which is completely unrealistic if <span class="math inline">\(N\)</span> is a number with (say) <span class="math inline">\(512\)</span> bits. This is because <span class="math inline">\(N \approx 2^{512}\)</span> is larger than estimates for the age of the Universe in femtoseconds! Alternatively, she could try to factor <span class="math inline">\(N\)</span> to retrieve <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, and then figure out <span class="math inline">\(d\)</span> by computing the inverse of <span class="math inline">\(e\)</span> mod <span class="math inline">\((p-1)(q-1)\)</span>; but this approach requires Eve to be able to <span><em>factor</em></span> <span class="math inline">\(N\)</span> into its prime factors, a problem which is believed to be impossible to solve efficiently for large values of <span class="math inline">\(N\)</span>. She could try to compute the quantity <span class="math inline">\((p-1)(q-1)\)</span> without factoring <span class="math inline">\(N\)</span>; but it is possible to show that computing <span class="math inline">\((p-1)(q-1)\)</span> is equivalent to factoring <span class="math inline">\(N\)</span>. We should point out that the security of RSA has not been formally proved: it rests on the assumptions that breaking RSA is essentially tantamount to factoring <span class="math inline">\(N\)</span>, and that factoring is hard.</p>
<p>We close this note with a brief discussion of implementation issues for RSA. Since we have argued that breaking RSA is impossible because <span><em>factoring</em></span> would take a very long time, we should check that the computations that Alice and Bob themselves have to perform are much simpler, and can be done efficiently.</p>
<p>There are really only two non-trivial things that Alice and Bob have to do:</p>
<ol style="list-style-type: decimal">
<li><p>Bob has to find prime numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, each having many (say, <span class="math inline">\(512\)</span>) bits.</p></li>
<li><p>Both Alice and Bob have to compute exponentials mod <span class="math inline">\(N\)</span>. (Alice has to compute <span class="math inline">\(x^e\bmod N\)</span>, and Bob has to compute <span class="math inline">\(y^d\bmod N\)</span>.)</p></li>
</ol>
<p>Both of these tasks can be carried out efficiently. The first requires a rich source of primes<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. You will learn how to do this task in the upper-division algorithms course 170, and this is based on results from number theory. The second requires an efficient algorithm for modular exponentiation, which you have already seen in the previous note. You can further speed up the decryption step by leaning on the Chinese Remainder Theorem and working in coordinates mod <span class="math inline">\(p\)</span> and mod <span class="math inline">\(q\)</span>.</p>
<p>To summarize, then, in the RSA protocol Bob need only perform simple calculations such as multiplication, exponentiation and primality testing to implement his digital lock. Similarly, Alice and Bob need only perform simple calculations to lock and unlock the the message respectively—operations that any pocket computing device could handle. By contrast, to unlock the message without the key, Eve would have to perform operations like factoring large numbers, which (at least according to widely accepted belief) requires more computational power than all the world’s most sophisticated computers combined! This compelling guarantee of security without the need for private keys explains why the RSA cryptosystem is such a revolutionary development in cryptography.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>And in reality, involving some of the same cast of characters. Both Alan Turing and Claude Shannon were active in codebreaking during the war and Shannon had a classic paper that is considered the birth of the information-theoretic understanding of secrecy and dovetails with his other more famous paper that gave rise to the modern information-theoretic view of communication. Both cryptography and communication weave together information, computation, and randomness in surprising ways. In 70, you just get a tiny taste of these spectacularly beautiful fields.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This sort of thing is something that we will be doing often in this course — looking at the same thing in two different ways.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>To find large prime numbers, we use the fact that, given a positive integer <span class="math inline">\(n\)</span>, there is an efficient algorithm that determines whether or not <span class="math inline">\(n\)</span> is prime. (Here “efficient&quot; means a running time of <span class="math inline">\(O((\log n)^k)\)</span> for some small <span class="math inline">\(k\)</span>, i.e., a low-degree power of the <span><em>number of bits in</em></span> <span class="math inline">\(n\)</span>. Notice the dramatic contrast here with factoring: we can tell efficiently whether or not <span class="math inline">\(n\)</span> is prime, but in the case that it is not prime we cannot efficiently find its factors. The success of RSA hinges crucially on this distinction.) Given that we can test for primes, Bob just needs to generate some random integers <span class="math inline">\(n\)</span> with the right number of bits, and test them until he finds two primes <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. This works because of the following basic fact from number theory (which we will not prove), which says that a reasonably large fraction of positive integers are prime:</p>
<p><span id="thm:prime" class="pandoc-numbering-text thm"><strong>Theorem 3</strong> <em>(Prime Number Theorem)</em></span></p>
<p><em>Let <span class="math inline">\(\pi(n)\)</span> denote the number of primes that are less than or equal to <span class="math inline">\(n\)</span>. Then for all <span class="math inline">\(n\ge 17\)</span>, we have</em> <span class="math display">\[\pi(n)\ge\frac{n}{\ln n}.\]</span> <em>In fact,</em> <span class="math display">\[\lim_{n\to\infty}\frac{\pi(n)}{n/\ln n} = 1.\]</span></p>
<p>Setting <span class="math inline">\(n=2^{512}\)</span>, for example, the Prime Number Theorem says that roughly one in every <span class="math inline">\(355\)</span> of all <span class="math inline">\(512\)</span>-bit numbers are prime. Therefore, if we keep picking random <span class="math inline">\(512\)</span>-bit numbers and testing them, we would expect to have to try only about <span class="math inline">\(355\)</span> numbers until we find a prime.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
</article>
</body>

<!-- Mirrored from www.eecs70.org/static/notes/n7.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 May 2018 00:39:26 GMT -->
</html>
